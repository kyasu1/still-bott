schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

type GetTokenOutput {
  token: String
}

type GetUserOutput {
  username: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "media"
"""
type media {
  id: uuid!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!
  thumbnail: String!
  uploaded_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "media"
"""
type media_aggregate {
  aggregate: media_aggregate_fields
  nodes: [media!]!
}

input media_aggregate_bool_exp {
  count: media_aggregate_bool_exp_count
}

input media_aggregate_bool_exp_count {
  arguments: [media_select_column!]
  distinct: Boolean
  filter: media_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "media"
"""
type media_aggregate_fields {
  count(columns: [media_select_column!], distinct: Boolean): Int!
  max: media_max_fields
  min: media_min_fields
}

"""
order by aggregate values of table "media"
"""
input media_aggregate_order_by {
  count: order_by
  max: media_max_order_by
  min: media_min_order_by
}

"""
input type for inserting array relation for remote table "media"
"""
input media_arr_rel_insert_input {
  data: [media_insert_input!]!

  """upsert condition"""
  on_conflict: media_on_conflict
}

"""
Boolean expression to filter rows from the table "media". All fields are combined with a logical 'AND'.
"""
input media_bool_exp {
  _and: [media_bool_exp!]
  _not: media_bool_exp
  _or: [media_bool_exp!]
  id: uuid_comparison_exp
  messages: message_bool_exp
  messages_aggregate: message_aggregate_bool_exp
  thumbnail: String_comparison_exp
  uploaded_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "media"
"""
enum media_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_pkey
}

"""
input type for inserting data into table "media"
"""
input media_insert_input {
  id: uuid
  messages: message_arr_rel_insert_input
  thumbnail: String
  uploaded_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type media_max_fields {
  id: uuid
  thumbnail: String
  uploaded_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "media"
"""
input media_max_order_by {
  id: order_by
  thumbnail: order_by
  uploaded_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type media_min_fields {
  id: uuid
  thumbnail: String
  uploaded_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "media"
"""
input media_min_order_by {
  id: order_by
  thumbnail: order_by
  uploaded_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "media"
"""
type media_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [media!]!
}

"""
input type for inserting object relation for remote table "media"
"""
input media_obj_rel_insert_input {
  data: media_insert_input!

  """upsert condition"""
  on_conflict: media_on_conflict
}

"""
on_conflict condition type for table "media"
"""
input media_on_conflict {
  constraint: media_constraint!
  update_columns: [media_update_column!]! = []
  where: media_bool_exp
}

"""Ordering options when selecting data from "media"."""
input media_order_by {
  id: order_by
  messages_aggregate: message_aggregate_order_by
  thumbnail: order_by
  uploaded_at: order_by
  user_id: order_by
}

"""primary key columns input for table: media"""
input media_pk_columns_input {
  id: uuid!
}

"""
select columns of table "media"
"""
enum media_select_column {
  """column name"""
  id

  """column name"""
  thumbnail

  """column name"""
  uploaded_at

  """column name"""
  user_id
}

"""
input type for updating data in table "media"
"""
input media_set_input {
  id: uuid
  thumbnail: String
  uploaded_at: timestamptz
  user_id: String
}

"""
Streaming cursor of the table "media"
"""
input media_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: media_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input media_stream_cursor_value_input {
  id: uuid
  thumbnail: String
  uploaded_at: timestamptz
  user_id: String
}

"""
update columns of table "media"
"""
enum media_update_column {
  """column name"""
  id

  """column name"""
  thumbnail

  """column name"""
  uploaded_at

  """column name"""
  user_id
}

input media_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: media_set_input

  """filter the rows which have to be updated"""
  where: media_bool_exp!
}

"""
columns and relationships of "message"
"""
type message {
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  media: media
  media_id: uuid
  priority: Int!

  """An object relationship"""
  tag: tag
  tag_id: uuid
  text: String!
  tweeted: Boolean!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_id: String!
}

"""
aggregated selection of "message"
"""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

input message_aggregate_bool_exp {
  bool_and: message_aggregate_bool_exp_bool_and
  bool_or: message_aggregate_bool_exp_bool_or
  count: message_aggregate_bool_exp_count
}

input message_aggregate_bool_exp_bool_and {
  arguments: message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: message_bool_exp
  predicate: Boolean_comparison_exp!
}

input message_aggregate_bool_exp_bool_or {
  arguments: message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: message_bool_exp
  predicate: Boolean_comparison_exp!
}

input message_aggregate_bool_exp_count {
  arguments: [message_select_column!]
  distinct: Boolean
  filter: message_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "message"
"""
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!], distinct: Boolean): Int!
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

"""
order by aggregate values of table "message"
"""
input message_aggregate_order_by {
  avg: message_avg_order_by
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
  stddev: message_stddev_order_by
  stddev_pop: message_stddev_pop_order_by
  stddev_samp: message_stddev_samp_order_by
  sum: message_sum_order_by
  var_pop: message_var_pop_order_by
  var_samp: message_var_samp_order_by
  variance: message_variance_order_by
}

"""
input type for inserting array relation for remote table "message"
"""
input message_arr_rel_insert_input {
  data: [message_insert_input!]!

  """upsert condition"""
  on_conflict: message_on_conflict
}

"""aggregate avg on columns"""
type message_avg_fields {
  priority: Float
}

"""
order by avg() on columns of table "message"
"""
input message_avg_order_by {
  priority: order_by
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input message_bool_exp {
  _and: [message_bool_exp!]
  _not: message_bool_exp
  _or: [message_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  media: media_bool_exp
  media_id: uuid_comparison_exp
  priority: Int_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
  text: String_comparison_exp
  tweeted: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "message"
"""
enum message_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_pkey
}

"""
input type for incrementing numeric columns in table "message"
"""
input message_inc_input {
  priority: Int
}

"""
input type for inserting data into table "message"
"""
input message_insert_input {
  created_at: timestamptz
  id: uuid
  media: media_obj_rel_insert_input
  media_id: uuid
  priority: Int
  tag: tag_obj_rel_insert_input
  tag_id: uuid
  text: String
  tweeted: Boolean
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type message_max_fields {
  created_at: timestamptz
  id: uuid
  media_id: uuid
  priority: Int
  tag_id: uuid
  text: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "message"
"""
input message_max_order_by {
  created_at: order_by
  id: order_by
  media_id: order_by
  priority: order_by
  tag_id: order_by
  text: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type message_min_fields {
  created_at: timestamptz
  id: uuid
  media_id: uuid
  priority: Int
  tag_id: uuid
  text: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "message"
"""
input message_min_order_by {
  created_at: order_by
  id: order_by
  media_id: order_by
  priority: order_by
  tag_id: order_by
  text: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "message"
"""
type message_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [message!]!
}

"""
on_conflict condition type for table "message"
"""
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]! = []
  where: message_bool_exp
}

"""Ordering options when selecting data from "message"."""
input message_order_by {
  created_at: order_by
  id: order_by
  media: media_order_by
  media_id: order_by
  priority: order_by
  tag: tag_order_by
  tag_id: order_by
  text: order_by
  tweeted: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: message"""
input message_pk_columns_input {
  id: uuid!
}

"""
select columns of table "message"
"""
enum message_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  media_id

  """column name"""
  priority

  """column name"""
  tag_id

  """column name"""
  text

  """column name"""
  tweeted

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "message_aggregate_bool_exp_bool_and_arguments_columns" columns of table "message"
"""
enum message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  tweeted
}

"""
select "message_aggregate_bool_exp_bool_or_arguments_columns" columns of table "message"
"""
enum message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  tweeted
}

"""
input type for updating data in table "message"
"""
input message_set_input {
  created_at: timestamptz
  id: uuid
  media_id: uuid
  priority: Int
  tag_id: uuid
  text: String
  tweeted: Boolean
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type message_stddev_fields {
  priority: Float
}

"""
order by stddev() on columns of table "message"
"""
input message_stddev_order_by {
  priority: order_by
}

"""aggregate stddev_pop on columns"""
type message_stddev_pop_fields {
  priority: Float
}

"""
order by stddev_pop() on columns of table "message"
"""
input message_stddev_pop_order_by {
  priority: order_by
}

"""aggregate stddev_samp on columns"""
type message_stddev_samp_fields {
  priority: Float
}

"""
order by stddev_samp() on columns of table "message"
"""
input message_stddev_samp_order_by {
  priority: order_by
}

"""
Streaming cursor of the table "message"
"""
input message_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: message_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input message_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  media_id: uuid
  priority: Int
  tag_id: uuid
  text: String
  tweeted: Boolean
  updated_at: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type message_sum_fields {
  priority: Int
}

"""
order by sum() on columns of table "message"
"""
input message_sum_order_by {
  priority: order_by
}

"""
update columns of table "message"
"""
enum message_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  media_id

  """column name"""
  priority

  """column name"""
  tag_id

  """column name"""
  text

  """column name"""
  tweeted

  """column name"""
  updated_at

  """column name"""
  user_id
}

input message_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: message_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: message_set_input

  """filter the rows which have to be updated"""
  where: message_bool_exp!
}

"""aggregate var_pop on columns"""
type message_var_pop_fields {
  priority: Float
}

"""
order by var_pop() on columns of table "message"
"""
input message_var_pop_order_by {
  priority: order_by
}

"""aggregate var_samp on columns"""
type message_var_samp_fields {
  priority: Float
}

"""
order by var_samp() on columns of table "message"
"""
input message_var_samp_order_by {
  priority: order_by
}

"""aggregate variance on columns"""
type message_variance_fields {
  priority: Float
}

"""
order by variance() on columns of table "message"
"""
input message_variance_order_by {
  priority: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "media"
  """
  delete_media(
    """filter the rows which have to be deleted"""
    where: media_bool_exp!
  ): media_mutation_response

  """
  delete single row from the table: "media"
  """
  delete_media_by_pk(id: uuid!): media

  """
  delete data from the table: "message"
  """
  delete_message(
    """filter the rows which have to be deleted"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  delete single row from the table: "message"
  """
  delete_message_by_pk(id: uuid!): message

  """
  delete data from the table: "role"
  """
  delete_role(
    """filter the rows which have to be deleted"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "role"
  """
  delete_role_by_pk(value: String!): role

  """
  delete data from the table: "session"
  """
  delete_session(
    """filter the rows which have to be deleted"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  delete single row from the table: "session"
  """
  delete_session_by_pk(id: String!): session

  """
  delete data from the table: "tag"
  """
  delete_tag(
    """filter the rows which have to be deleted"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "tag"
  """
  delete_tag_by_pk(id: uuid!): tag

  """
  delete data from the table: "task_fixed_time"
  """
  delete_task_fixed_time(
    """filter the rows which have to be deleted"""
    where: task_fixed_time_bool_exp!
  ): task_fixed_time_mutation_response

  """
  delete single row from the table: "task_fixed_time"
  """
  delete_task_fixed_time_by_pk(id: uuid!): task_fixed_time

  """
  delete data from the table: "task_rss"
  """
  delete_task_rss(
    """filter the rows which have to be deleted"""
    where: task_rss_bool_exp!
  ): task_rss_mutation_response

  """
  delete single row from the table: "task_rss"
  """
  delete_task_rss_by_pk(id: uuid!): task_rss

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user

  """
  insert data into the table: "media"
  """
  insert_media(
    """the rows to be inserted"""
    objects: [media_insert_input!]!

    """upsert condition"""
    on_conflict: media_on_conflict
  ): media_mutation_response

  """
  insert a single row into the table: "media"
  """
  insert_media_one(
    """the row to be inserted"""
    object: media_insert_input!

    """upsert condition"""
    on_conflict: media_on_conflict
  ): media

  """
  insert data into the table: "message"
  """
  insert_message(
    """the rows to be inserted"""
    objects: [message_insert_input!]!

    """upsert condition"""
    on_conflict: message_on_conflict
  ): message_mutation_response

  """
  insert a single row into the table: "message"
  """
  insert_message_one(
    """the row to be inserted"""
    object: message_insert_input!

    """upsert condition"""
    on_conflict: message_on_conflict
  ): message

  """
  insert data into the table: "role"
  """
  insert_role(
    """the rows to be inserted"""
    objects: [role_insert_input!]!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  insert a single row into the table: "role"
  """
  insert_role_one(
    """the row to be inserted"""
    object: role_insert_input!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role

  """
  insert data into the table: "session"
  """
  insert_session(
    """the rows to be inserted"""
    objects: [session_insert_input!]!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session_mutation_response

  """
  insert a single row into the table: "session"
  """
  insert_session_one(
    """the row to be inserted"""
    object: session_insert_input!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session

  """
  insert data into the table: "tag"
  """
  insert_tag(
    """the rows to be inserted"""
    objects: [tag_insert_input!]!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  insert a single row into the table: "tag"
  """
  insert_tag_one(
    """the row to be inserted"""
    object: tag_insert_input!

    """upsert condition"""
    on_conflict: tag_on_conflict
  ): tag

  """
  insert data into the table: "task_fixed_time"
  """
  insert_task_fixed_time(
    """the rows to be inserted"""
    objects: [task_fixed_time_insert_input!]!

    """upsert condition"""
    on_conflict: task_fixed_time_on_conflict
  ): task_fixed_time_mutation_response

  """
  insert a single row into the table: "task_fixed_time"
  """
  insert_task_fixed_time_one(
    """the row to be inserted"""
    object: task_fixed_time_insert_input!

    """upsert condition"""
    on_conflict: task_fixed_time_on_conflict
  ): task_fixed_time

  """
  insert data into the table: "task_rss"
  """
  insert_task_rss(
    """the rows to be inserted"""
    objects: [task_rss_insert_input!]!

    """upsert condition"""
    on_conflict: task_rss_on_conflict
  ): task_rss_mutation_response

  """
  insert a single row into the table: "task_rss"
  """
  insert_task_rss_one(
    """the row to be inserted"""
    object: task_rss_insert_input!

    """upsert condition"""
    on_conflict: task_rss_on_conflict
  ): task_rss

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  update data of the table: "media"
  """
  update_media(
    """sets the columns of the filtered rows to the given values"""
    _set: media_set_input

    """filter the rows which have to be updated"""
    where: media_bool_exp!
  ): media_mutation_response

  """
  update single row of the table: "media"
  """
  update_media_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: media_set_input
    pk_columns: media_pk_columns_input!
  ): media

  """
  update multiples rows of table: "media"
  """
  update_media_many(
    """updates to execute, in order"""
    updates: [media_updates!]!
  ): [media_mutation_response]

  """
  update data of the table: "message"
  """
  update_message(
    """increments the numeric columns with given value of the filtered values"""
    _inc: message_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input

    """filter the rows which have to be updated"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  update single row of the table: "message"
  """
  update_message_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: message_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  """
  update multiples rows of table: "message"
  """
  update_message_many(
    """updates to execute, in order"""
    updates: [message_updates!]!
  ): [message_mutation_response]

  """
  update data of the table: "role"
  """
  update_role(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input

    """filter the rows which have to be updated"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  update single row of the table: "role"
  """
  update_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  update multiples rows of table: "role"
  """
  update_role_many(
    """updates to execute, in order"""
    updates: [role_updates!]!
  ): [role_mutation_response]

  """
  update data of the table: "session"
  """
  update_session(
    """increments the numeric columns with given value of the filtered values"""
    _inc: session_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input

    """filter the rows which have to be updated"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  update single row of the table: "session"
  """
  update_session_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: session_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input
    pk_columns: session_pk_columns_input!
  ): session

  """
  update multiples rows of table: "session"
  """
  update_session_many(
    """updates to execute, in order"""
    updates: [session_updates!]!
  ): [session_mutation_response]

  """
  update data of the table: "tag"
  """
  update_tag(
    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input

    """filter the rows which have to be updated"""
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  update single row of the table: "tag"
  """
  update_tag_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  update multiples rows of table: "tag"
  """
  update_tag_many(
    """updates to execute, in order"""
    updates: [tag_updates!]!
  ): [tag_mutation_response]

  """
  update data of the table: "task_fixed_time"
  """
  update_task_fixed_time(
    """sets the columns of the filtered rows to the given values"""
    _set: task_fixed_time_set_input

    """filter the rows which have to be updated"""
    where: task_fixed_time_bool_exp!
  ): task_fixed_time_mutation_response

  """
  update single row of the table: "task_fixed_time"
  """
  update_task_fixed_time_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_fixed_time_set_input
    pk_columns: task_fixed_time_pk_columns_input!
  ): task_fixed_time

  """
  update multiples rows of table: "task_fixed_time"
  """
  update_task_fixed_time_many(
    """updates to execute, in order"""
    updates: [task_fixed_time_updates!]!
  ): [task_fixed_time_mutation_response]

  """
  update data of the table: "task_rss"
  """
  update_task_rss(
    """sets the columns of the filtered rows to the given values"""
    _set: task_rss_set_input

    """filter the rows which have to be updated"""
    where: task_rss_bool_exp!
  ): task_rss_mutation_response

  """
  update single row of the table: "task_rss"
  """
  update_task_rss_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: task_rss_set_input
    pk_columns: task_rss_pk_columns_input!
  ): task_rss

  """
  update multiples rows of table: "task_rss"
  """
  update_task_rss_many(
    """updates to execute, in order"""
    updates: [task_rss_updates!]!
  ): [task_rss_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  getToken(user_id: String!): GetTokenOutput
  getUser(user_id: String!): GetUserOutput

  """
  fetch data from the table: "media"
  """
  media(
    """distinct select on columns"""
    distinct_on: [media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_order_by!]

    """filter the rows returned"""
    where: media_bool_exp
  ): [media!]!

  """
  fetch aggregated fields from the table: "media"
  """
  media_aggregate(
    """distinct select on columns"""
    distinct_on: [media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_order_by!]

    """filter the rows returned"""
    where: media_bool_exp
  ): media_aggregate!

  """fetch data from the table: "media" using primary key columns"""
  media_by_pk(id: uuid!): media

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """fetch data from the table: "message" using primary key columns"""
  message_by_pk(id: uuid!): message

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(value: String!): role

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(id: String!): session

  """An array relationship"""
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table: "task_fixed_time"
  """
  task_fixed_time(
    """distinct select on columns"""
    distinct_on: [task_fixed_time_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_fixed_time_order_by!]

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): [task_fixed_time!]!

  """
  fetch aggregated fields from the table: "task_fixed_time"
  """
  task_fixed_time_aggregate(
    """distinct select on columns"""
    distinct_on: [task_fixed_time_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_fixed_time_order_by!]

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): task_fixed_time_aggregate!

  """fetch data from the table: "task_fixed_time" using primary key columns"""
  task_fixed_time_by_pk(id: uuid!): task_fixed_time

  """
  fetch data from the table: "task_rss"
  """
  task_rss(
    """distinct select on columns"""
    distinct_on: [task_rss_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_rss_order_by!]

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): [task_rss!]!

  """
  fetch aggregated fields from the table: "task_rss"
  """
  task_rss_aggregate(
    """distinct select on columns"""
    distinct_on: [task_rss_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_rss_order_by!]

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): task_rss_aggregate!

  """fetch data from the table: "task_rss" using primary key columns"""
  task_rss_by_pk(id: uuid!): task_rss

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user
}

"""
columns and relationships of "role"
"""
type role {
  value: String!
}

"""
aggregated selection of "role"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

"""
aggregate fields of "role"
"""
type role_aggregate_fields {
  count(columns: [role_select_column!], distinct: Boolean): Int!
  max: role_max_fields
  min: role_min_fields
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp!]
  _not: role_bool_exp
  _or: [role_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "role"
"""
enum role_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  role_pkey
}

enum role_enum {
  anonymous
  basic
  premium
}

"""
Boolean expression to compare columns of type "role_enum". All fields are combined with logical 'AND'.
"""
input role_enum_comparison_exp {
  _eq: role_enum
  _in: [role_enum!]
  _is_null: Boolean
  _neq: role_enum
  _nin: [role_enum!]
}

"""
input type for inserting data into table "role"
"""
input role_insert_input {
  value: String
}

"""aggregate max on columns"""
type role_max_fields {
  value: String
}

"""aggregate min on columns"""
type role_min_fields {
  value: String
}

"""
response of any mutation on the table "role"
"""
type role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role!]!
}

"""
on_conflict condition type for table "role"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]! = []
  where: role_bool_exp
}

"""Ordering options when selecting data from "role"."""
input role_order_by {
  value: order_by
}

"""primary key columns input for table: role"""
input role_pk_columns_input {
  value: String!
}

"""
select columns of table "role"
"""
enum role_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "role"
"""
input role_set_input {
  value: String
}

"""
Streaming cursor of the table "role"
"""
input role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_stream_cursor_value_input {
  value: String
}

"""
update columns of table "role"
"""
enum role_update_column {
  """column name"""
  value
}

input role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: role_set_input

  """filter the rows which have to be updated"""
  where: role_bool_exp!
}

"""
columns and relationships of "session"
"""
type session {
  access_token: String!
  expires_in: Int
  id: String!
  issued_at: timestamptz!
  name: String
  refresh_token: String
  user_name: String
}

"""
aggregated selection of "session"
"""
type session_aggregate {
  aggregate: session_aggregate_fields
  nodes: [session!]!
}

"""
aggregate fields of "session"
"""
type session_aggregate_fields {
  avg: session_avg_fields
  count(columns: [session_select_column!], distinct: Boolean): Int!
  max: session_max_fields
  min: session_min_fields
  stddev: session_stddev_fields
  stddev_pop: session_stddev_pop_fields
  stddev_samp: session_stddev_samp_fields
  sum: session_sum_fields
  var_pop: session_var_pop_fields
  var_samp: session_var_samp_fields
  variance: session_variance_fields
}

"""aggregate avg on columns"""
type session_avg_fields {
  expires_in: Float
}

"""
Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
"""
input session_bool_exp {
  _and: [session_bool_exp!]
  _not: session_bool_exp
  _or: [session_bool_exp!]
  access_token: String_comparison_exp
  expires_in: Int_comparison_exp
  id: String_comparison_exp
  issued_at: timestamptz_comparison_exp
  name: String_comparison_exp
  refresh_token: String_comparison_exp
  user_name: String_comparison_exp
}

"""
unique or primary key constraints on table "session"
"""
enum session_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  session_pkey
}

"""
input type for incrementing numeric columns in table "session"
"""
input session_inc_input {
  expires_in: Int
}

"""
input type for inserting data into table "session"
"""
input session_insert_input {
  access_token: String
  expires_in: Int
  id: String
  issued_at: timestamptz
  name: String
  refresh_token: String
  user_name: String
}

"""aggregate max on columns"""
type session_max_fields {
  access_token: String
  expires_in: Int
  id: String
  issued_at: timestamptz
  name: String
  refresh_token: String
  user_name: String
}

"""aggregate min on columns"""
type session_min_fields {
  access_token: String
  expires_in: Int
  id: String
  issued_at: timestamptz
  name: String
  refresh_token: String
  user_name: String
}

"""
response of any mutation on the table "session"
"""
type session_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [session!]!
}

"""
on_conflict condition type for table "session"
"""
input session_on_conflict {
  constraint: session_constraint!
  update_columns: [session_update_column!]! = []
  where: session_bool_exp
}

"""Ordering options when selecting data from "session"."""
input session_order_by {
  access_token: order_by
  expires_in: order_by
  id: order_by
  issued_at: order_by
  name: order_by
  refresh_token: order_by
  user_name: order_by
}

"""primary key columns input for table: session"""
input session_pk_columns_input {
  id: String!
}

"""
select columns of table "session"
"""
enum session_select_column {
  """column name"""
  access_token

  """column name"""
  expires_in

  """column name"""
  id

  """column name"""
  issued_at

  """column name"""
  name

  """column name"""
  refresh_token

  """column name"""
  user_name
}

"""
input type for updating data in table "session"
"""
input session_set_input {
  access_token: String
  expires_in: Int
  id: String
  issued_at: timestamptz
  name: String
  refresh_token: String
  user_name: String
}

"""aggregate stddev on columns"""
type session_stddev_fields {
  expires_in: Float
}

"""aggregate stddev_pop on columns"""
type session_stddev_pop_fields {
  expires_in: Float
}

"""aggregate stddev_samp on columns"""
type session_stddev_samp_fields {
  expires_in: Float
}

"""
Streaming cursor of the table "session"
"""
input session_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: session_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input session_stream_cursor_value_input {
  access_token: String
  expires_in: Int
  id: String
  issued_at: timestamptz
  name: String
  refresh_token: String
  user_name: String
}

"""aggregate sum on columns"""
type session_sum_fields {
  expires_in: Int
}

"""
update columns of table "session"
"""
enum session_update_column {
  """column name"""
  access_token

  """column name"""
  expires_in

  """column name"""
  id

  """column name"""
  issued_at

  """column name"""
  name

  """column name"""
  refresh_token

  """column name"""
  user_name
}

input session_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: session_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: session_set_input

  """filter the rows which have to be updated"""
  where: session_bool_exp!
}

"""aggregate var_pop on columns"""
type session_var_pop_fields {
  expires_in: Float
}

"""aggregate var_samp on columns"""
type session_var_samp_fields {
  expires_in: Float
}

"""aggregate variance on columns"""
type session_variance_fields {
  expires_in: Float
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "media"
  """
  media(
    """distinct select on columns"""
    distinct_on: [media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_order_by!]

    """filter the rows returned"""
    where: media_bool_exp
  ): [media!]!

  """
  fetch aggregated fields from the table: "media"
  """
  media_aggregate(
    """distinct select on columns"""
    distinct_on: [media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_order_by!]

    """filter the rows returned"""
    where: media_bool_exp
  ): media_aggregate!

  """fetch data from the table: "media" using primary key columns"""
  media_by_pk(id: uuid!): media

  """
  fetch data from the table in a streaming manner: "media"
  """
  media_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [media_stream_cursor_input]!

    """filter the rows returned"""
    where: media_bool_exp
  ): [media!]!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """fetch data from the table: "message" using primary key columns"""
  message_by_pk(id: uuid!): message

  """
  fetch data from the table in a streaming manner: "message"
  """
  message_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [message_stream_cursor_input]!

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(value: String!): role

  """
  fetch data from the table in a streaming manner: "role"
  """
  role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_stream_cursor_input]!

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(id: String!): session

  """
  fetch data from the table in a streaming manner: "session"
  """
  session_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [session_stream_cursor_input]!

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """An array relationship"""
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """fetch data from the table: "tag" using primary key columns"""
  tag_by_pk(id: uuid!): tag

  """
  fetch data from the table in a streaming manner: "tag"
  """
  tag_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tag_stream_cursor_input]!

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch data from the table: "task_fixed_time"
  """
  task_fixed_time(
    """distinct select on columns"""
    distinct_on: [task_fixed_time_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_fixed_time_order_by!]

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): [task_fixed_time!]!

  """
  fetch aggregated fields from the table: "task_fixed_time"
  """
  task_fixed_time_aggregate(
    """distinct select on columns"""
    distinct_on: [task_fixed_time_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_fixed_time_order_by!]

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): task_fixed_time_aggregate!

  """fetch data from the table: "task_fixed_time" using primary key columns"""
  task_fixed_time_by_pk(id: uuid!): task_fixed_time

  """
  fetch data from the table in a streaming manner: "task_fixed_time"
  """
  task_fixed_time_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [task_fixed_time_stream_cursor_input]!

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): [task_fixed_time!]!

  """
  fetch data from the table: "task_rss"
  """
  task_rss(
    """distinct select on columns"""
    distinct_on: [task_rss_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_rss_order_by!]

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): [task_rss!]!

  """
  fetch aggregated fields from the table: "task_rss"
  """
  task_rss_aggregate(
    """distinct select on columns"""
    distinct_on: [task_rss_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_rss_order_by!]

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): task_rss_aggregate!

  """fetch data from the table: "task_rss" using primary key columns"""
  task_rss_by_pk(id: uuid!): task_rss

  """
  fetch data from the table in a streaming manner: "task_rss"
  """
  task_rss_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [task_rss_stream_cursor_input]!

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): [task_rss!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

"""
columns and relationships of "tag"
"""
type tag {
  description: String
  id: uuid!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!
  name: String!

  """An object relationship"""
  user: user!
  user_id: String!
}

"""
aggregated selection of "tag"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

input tag_aggregate_bool_exp {
  count: tag_aggregate_bool_exp_count
}

input tag_aggregate_bool_exp_count {
  arguments: [tag_select_column!]
  distinct: Boolean
  filter: tag_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tag"
"""
type tag_aggregate_fields {
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
}

"""
order by aggregate values of table "tag"
"""
input tag_aggregate_order_by {
  count: order_by
  max: tag_max_order_by
  min: tag_min_order_by
}

"""
input type for inserting array relation for remote table "tag"
"""
input tag_arr_rel_insert_input {
  data: [tag_insert_input!]!

  """upsert condition"""
  on_conflict: tag_on_conflict
}

"""
Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  description: String_comparison_exp
  id: uuid_comparison_exp
  messages: message_bool_exp
  messages_aggregate: message_aggregate_bool_exp
  name: String_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "tag"
"""
enum tag_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tag_pkey
}

"""
input type for inserting data into table "tag"
"""
input tag_insert_input {
  description: String
  id: uuid
  messages: message_arr_rel_insert_input
  name: String
  user: user_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type tag_max_fields {
  description: String
  id: uuid
  name: String
  user_id: String
}

"""
order by max() on columns of table "tag"
"""
input tag_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type tag_min_fields {
  description: String
  id: uuid
  name: String
  user_id: String
}

"""
order by min() on columns of table "tag"
"""
input tag_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  user_id: order_by
}

"""
response of any mutation on the table "tag"
"""
type tag_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tag!]!
}

"""
input type for inserting object relation for remote table "tag"
"""
input tag_obj_rel_insert_input {
  data: tag_insert_input!

  """upsert condition"""
  on_conflict: tag_on_conflict
}

"""
on_conflict condition type for table "tag"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]! = []
  where: tag_bool_exp
}

"""Ordering options when selecting data from "tag"."""
input tag_order_by {
  description: order_by
  id: order_by
  messages_aggregate: message_aggregate_order_by
  name: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: tag"""
input tag_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tag"
"""
enum tag_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  user_id
}

"""
input type for updating data in table "tag"
"""
input tag_set_input {
  description: String
  id: uuid
  name: String
  user_id: String
}

"""
Streaming cursor of the table "tag"
"""
input tag_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tag_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tag_stream_cursor_value_input {
  description: String
  id: uuid
  name: String
  user_id: String
}

"""
update columns of table "tag"
"""
enum tag_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  user_id
}

input tag_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tag_set_input

  """filter the rows which have to be updated"""
  where: tag_bool_exp!
}

"""
columns and relationships of "task_fixed_time"
"""
type task_fixed_time {
  created_at: timestamptz!
  enabled: Boolean!
  fri: Boolean!
  id: uuid!
  mon: Boolean!
  random: Boolean!
  sat: Boolean!
  sun: Boolean!

  """An object relationship"""
  tag: tag
  tag_id: uuid
  thu: Boolean!
  tue: Boolean!
  tweet_at: time!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_id: String!
  wed: Boolean!
}

"""
aggregated selection of "task_fixed_time"
"""
type task_fixed_time_aggregate {
  aggregate: task_fixed_time_aggregate_fields
  nodes: [task_fixed_time!]!
}

input task_fixed_time_aggregate_bool_exp {
  bool_and: task_fixed_time_aggregate_bool_exp_bool_and
  bool_or: task_fixed_time_aggregate_bool_exp_bool_or
  count: task_fixed_time_aggregate_bool_exp_count
}

input task_fixed_time_aggregate_bool_exp_bool_and {
  arguments: task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: task_fixed_time_bool_exp
  predicate: Boolean_comparison_exp!
}

input task_fixed_time_aggregate_bool_exp_bool_or {
  arguments: task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: task_fixed_time_bool_exp
  predicate: Boolean_comparison_exp!
}

input task_fixed_time_aggregate_bool_exp_count {
  arguments: [task_fixed_time_select_column!]
  distinct: Boolean
  filter: task_fixed_time_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "task_fixed_time"
"""
type task_fixed_time_aggregate_fields {
  count(columns: [task_fixed_time_select_column!], distinct: Boolean): Int!
  max: task_fixed_time_max_fields
  min: task_fixed_time_min_fields
}

"""
order by aggregate values of table "task_fixed_time"
"""
input task_fixed_time_aggregate_order_by {
  count: order_by
  max: task_fixed_time_max_order_by
  min: task_fixed_time_min_order_by
}

"""
input type for inserting array relation for remote table "task_fixed_time"
"""
input task_fixed_time_arr_rel_insert_input {
  data: [task_fixed_time_insert_input!]!

  """upsert condition"""
  on_conflict: task_fixed_time_on_conflict
}

"""
Boolean expression to filter rows from the table "task_fixed_time". All fields are combined with a logical 'AND'.
"""
input task_fixed_time_bool_exp {
  _and: [task_fixed_time_bool_exp!]
  _not: task_fixed_time_bool_exp
  _or: [task_fixed_time_bool_exp!]
  created_at: timestamptz_comparison_exp
  enabled: Boolean_comparison_exp
  fri: Boolean_comparison_exp
  id: uuid_comparison_exp
  mon: Boolean_comparison_exp
  random: Boolean_comparison_exp
  sat: Boolean_comparison_exp
  sun: Boolean_comparison_exp
  tag: tag_bool_exp
  tag_id: uuid_comparison_exp
  thu: Boolean_comparison_exp
  tue: Boolean_comparison_exp
  tweet_at: time_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
  wed: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "task_fixed_time"
"""
enum task_fixed_time_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  task_fixed_time_pkey
}

"""
input type for inserting data into table "task_fixed_time"
"""
input task_fixed_time_insert_input {
  created_at: timestamptz
  enabled: Boolean
  fri: Boolean
  id: uuid
  mon: Boolean
  random: Boolean
  sat: Boolean
  sun: Boolean
  tag: tag_obj_rel_insert_input
  tag_id: uuid
  thu: Boolean
  tue: Boolean
  tweet_at: time
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: String
  wed: Boolean
}

"""aggregate max on columns"""
type task_fixed_time_max_fields {
  created_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "task_fixed_time"
"""
input task_fixed_time_max_order_by {
  created_at: order_by
  id: order_by
  tag_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type task_fixed_time_min_fields {
  created_at: timestamptz
  id: uuid
  tag_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "task_fixed_time"
"""
input task_fixed_time_min_order_by {
  created_at: order_by
  id: order_by
  tag_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "task_fixed_time"
"""
type task_fixed_time_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task_fixed_time!]!
}

"""
on_conflict condition type for table "task_fixed_time"
"""
input task_fixed_time_on_conflict {
  constraint: task_fixed_time_constraint!
  update_columns: [task_fixed_time_update_column!]! = []
  where: task_fixed_time_bool_exp
}

"""Ordering options when selecting data from "task_fixed_time"."""
input task_fixed_time_order_by {
  created_at: order_by
  enabled: order_by
  fri: order_by
  id: order_by
  mon: order_by
  random: order_by
  sat: order_by
  sun: order_by
  tag: tag_order_by
  tag_id: order_by
  thu: order_by
  tue: order_by
  tweet_at: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
  wed: order_by
}

"""primary key columns input for table: task_fixed_time"""
input task_fixed_time_pk_columns_input {
  id: uuid!
}

"""
select columns of table "task_fixed_time"
"""
enum task_fixed_time_select_column {
  """column name"""
  created_at

  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  id

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  tag_id

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  tweet_at

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  wed
}

"""
select "task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns" columns of table "task_fixed_time"
"""
enum task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  wed
}

"""
select "task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns" columns of table "task_fixed_time"
"""
enum task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  wed
}

"""
input type for updating data in table "task_fixed_time"
"""
input task_fixed_time_set_input {
  created_at: timestamptz
  enabled: Boolean
  fri: Boolean
  id: uuid
  mon: Boolean
  random: Boolean
  sat: Boolean
  sun: Boolean
  tag_id: uuid
  thu: Boolean
  tue: Boolean
  tweet_at: time
  updated_at: timestamptz
  user_id: String
  wed: Boolean
}

"""
Streaming cursor of the table "task_fixed_time"
"""
input task_fixed_time_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: task_fixed_time_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input task_fixed_time_stream_cursor_value_input {
  created_at: timestamptz
  enabled: Boolean
  fri: Boolean
  id: uuid
  mon: Boolean
  random: Boolean
  sat: Boolean
  sun: Boolean
  tag_id: uuid
  thu: Boolean
  tue: Boolean
  tweet_at: time
  updated_at: timestamptz
  user_id: String
  wed: Boolean
}

"""
update columns of table "task_fixed_time"
"""
enum task_fixed_time_update_column {
  """column name"""
  created_at

  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  id

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  tag_id

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  tweet_at

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  wed
}

input task_fixed_time_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_fixed_time_set_input

  """filter the rows which have to be updated"""
  where: task_fixed_time_bool_exp!
}

"""
columns and relationships of "task_rss"
"""
type task_rss {
  created_at: timestamptz!
  enabled: Boolean!
  fri: Boolean!
  id: uuid!
  last_pub_date: timestamptz
  mon: Boolean!
  random: Boolean!
  sat: Boolean!
  sun: Boolean!
  template: String
  thu: Boolean!
  tue: Boolean!
  tweet_at: time!
  updated_at: timestamptz!
  url: String!

  """An object relationship"""
  user: user!
  user_id: String!
  wed: Boolean!
}

"""
aggregated selection of "task_rss"
"""
type task_rss_aggregate {
  aggregate: task_rss_aggregate_fields
  nodes: [task_rss!]!
}

input task_rss_aggregate_bool_exp {
  bool_and: task_rss_aggregate_bool_exp_bool_and
  bool_or: task_rss_aggregate_bool_exp_bool_or
  count: task_rss_aggregate_bool_exp_count
}

input task_rss_aggregate_bool_exp_bool_and {
  arguments: task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: task_rss_bool_exp
  predicate: Boolean_comparison_exp!
}

input task_rss_aggregate_bool_exp_bool_or {
  arguments: task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: task_rss_bool_exp
  predicate: Boolean_comparison_exp!
}

input task_rss_aggregate_bool_exp_count {
  arguments: [task_rss_select_column!]
  distinct: Boolean
  filter: task_rss_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "task_rss"
"""
type task_rss_aggregate_fields {
  count(columns: [task_rss_select_column!], distinct: Boolean): Int!
  max: task_rss_max_fields
  min: task_rss_min_fields
}

"""
order by aggregate values of table "task_rss"
"""
input task_rss_aggregate_order_by {
  count: order_by
  max: task_rss_max_order_by
  min: task_rss_min_order_by
}

"""
input type for inserting array relation for remote table "task_rss"
"""
input task_rss_arr_rel_insert_input {
  data: [task_rss_insert_input!]!

  """upsert condition"""
  on_conflict: task_rss_on_conflict
}

"""
Boolean expression to filter rows from the table "task_rss". All fields are combined with a logical 'AND'.
"""
input task_rss_bool_exp {
  _and: [task_rss_bool_exp!]
  _not: task_rss_bool_exp
  _or: [task_rss_bool_exp!]
  created_at: timestamptz_comparison_exp
  enabled: Boolean_comparison_exp
  fri: Boolean_comparison_exp
  id: uuid_comparison_exp
  last_pub_date: timestamptz_comparison_exp
  mon: Boolean_comparison_exp
  random: Boolean_comparison_exp
  sat: Boolean_comparison_exp
  sun: Boolean_comparison_exp
  template: String_comparison_exp
  thu: Boolean_comparison_exp
  tue: Boolean_comparison_exp
  tweet_at: time_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
  wed: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "task_rss"
"""
enum task_rss_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  task_rss_pkey
}

"""
input type for inserting data into table "task_rss"
"""
input task_rss_insert_input {
  created_at: timestamptz
  enabled: Boolean
  fri: Boolean
  id: uuid
  last_pub_date: timestamptz
  mon: Boolean
  random: Boolean
  sat: Boolean
  sun: Boolean
  template: String
  thu: Boolean
  tue: Boolean
  tweet_at: time
  updated_at: timestamptz
  url: String
  user: user_obj_rel_insert_input
  user_id: String
  wed: Boolean
}

"""aggregate max on columns"""
type task_rss_max_fields {
  created_at: timestamptz
  id: uuid
  last_pub_date: timestamptz
  template: String
  updated_at: timestamptz
  url: String
  user_id: String
}

"""
order by max() on columns of table "task_rss"
"""
input task_rss_max_order_by {
  created_at: order_by
  id: order_by
  last_pub_date: order_by
  template: order_by
  updated_at: order_by
  url: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type task_rss_min_fields {
  created_at: timestamptz
  id: uuid
  last_pub_date: timestamptz
  template: String
  updated_at: timestamptz
  url: String
  user_id: String
}

"""
order by min() on columns of table "task_rss"
"""
input task_rss_min_order_by {
  created_at: order_by
  id: order_by
  last_pub_date: order_by
  template: order_by
  updated_at: order_by
  url: order_by
  user_id: order_by
}

"""
response of any mutation on the table "task_rss"
"""
type task_rss_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [task_rss!]!
}

"""
on_conflict condition type for table "task_rss"
"""
input task_rss_on_conflict {
  constraint: task_rss_constraint!
  update_columns: [task_rss_update_column!]! = []
  where: task_rss_bool_exp
}

"""Ordering options when selecting data from "task_rss"."""
input task_rss_order_by {
  created_at: order_by
  enabled: order_by
  fri: order_by
  id: order_by
  last_pub_date: order_by
  mon: order_by
  random: order_by
  sat: order_by
  sun: order_by
  template: order_by
  thu: order_by
  tue: order_by
  tweet_at: order_by
  updated_at: order_by
  url: order_by
  user: user_order_by
  user_id: order_by
  wed: order_by
}

"""primary key columns input for table: task_rss"""
input task_rss_pk_columns_input {
  id: uuid!
}

"""
select columns of table "task_rss"
"""
enum task_rss_select_column {
  """column name"""
  created_at

  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  id

  """column name"""
  last_pub_date

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  template

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  tweet_at

  """column name"""
  updated_at

  """column name"""
  url

  """column name"""
  user_id

  """column name"""
  wed
}

"""
select "task_rss_aggregate_bool_exp_bool_and_arguments_columns" columns of table "task_rss"
"""
enum task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  wed
}

"""
select "task_rss_aggregate_bool_exp_bool_or_arguments_columns" columns of table "task_rss"
"""
enum task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  wed
}

"""
input type for updating data in table "task_rss"
"""
input task_rss_set_input {
  created_at: timestamptz
  enabled: Boolean
  fri: Boolean
  id: uuid
  last_pub_date: timestamptz
  mon: Boolean
  random: Boolean
  sat: Boolean
  sun: Boolean
  template: String
  thu: Boolean
  tue: Boolean
  tweet_at: time
  updated_at: timestamptz
  url: String
  user_id: String
  wed: Boolean
}

"""
Streaming cursor of the table "task_rss"
"""
input task_rss_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: task_rss_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input task_rss_stream_cursor_value_input {
  created_at: timestamptz
  enabled: Boolean
  fri: Boolean
  id: uuid
  last_pub_date: timestamptz
  mon: Boolean
  random: Boolean
  sat: Boolean
  sun: Boolean
  template: String
  thu: Boolean
  tue: Boolean
  tweet_at: time
  updated_at: timestamptz
  url: String
  user_id: String
  wed: Boolean
}

"""
update columns of table "task_rss"
"""
enum task_rss_update_column {
  """column name"""
  created_at

  """column name"""
  enabled

  """column name"""
  fri

  """column name"""
  id

  """column name"""
  last_pub_date

  """column name"""
  mon

  """column name"""
  random

  """column name"""
  sat

  """column name"""
  sun

  """column name"""
  template

  """column name"""
  thu

  """column name"""
  tue

  """column name"""
  tweet_at

  """column name"""
  updated_at

  """column name"""
  url

  """column name"""
  user_id

  """column name"""
  wed
}

input task_rss_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: task_rss_set_input

  """filter the rows which have to be updated"""
  where: task_rss_bool_exp!
}

scalar time

"""
Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'.
"""
input time_comparison_exp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _is_null: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user"
"""
type user {
  active: Boolean!
  email: String!
  email_confirm_code: String
  email_confirm_code_issued_at: timestamptz
  email_confirmed: Boolean!
  email_confirmed_at: timestamptz
  id: String!
  last_seen: timestamptz!

  """An array relationship"""
  medias(
    """distinct select on columns"""
    distinct_on: [media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_order_by!]

    """filter the rows returned"""
    where: media_bool_exp
  ): [media!]!

  """An aggregate relationship"""
  medias_aggregate(
    """distinct select on columns"""
    distinct_on: [media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_order_by!]

    """filter the rows returned"""
    where: media_bool_exp
  ): media_aggregate!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!
  registered_at: timestamptz!
  role: role_enum!

  """An array relationship"""
  tag(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): [tag!]!

  """An aggregate relationship"""
  tag_aggregate(
    """distinct select on columns"""
    distinct_on: [tag_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tag_order_by!]

    """filter the rows returned"""
    where: tag_bool_exp
  ): tag_aggregate!

  """An array relationship"""
  tasks_fixed_time(
    """distinct select on columns"""
    distinct_on: [task_fixed_time_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_fixed_time_order_by!]

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): [task_fixed_time!]!

  """An aggregate relationship"""
  tasks_fixed_time_aggregate(
    """distinct select on columns"""
    distinct_on: [task_fixed_time_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_fixed_time_order_by!]

    """filter the rows returned"""
    where: task_fixed_time_bool_exp
  ): task_fixed_time_aggregate!

  """An array relationship"""
  tasks_rss(
    """distinct select on columns"""
    distinct_on: [task_rss_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_rss_order_by!]

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): [task_rss!]!

  """An aggregate relationship"""
  tasks_rss_aggregate(
    """distinct select on columns"""
    distinct_on: [task_rss_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [task_rss_order_by!]

    """filter the rows returned"""
    where: task_rss_bool_exp
  ): task_rss_aggregate!
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  active: Boolean_comparison_exp
  email: String_comparison_exp
  email_confirm_code: String_comparison_exp
  email_confirm_code_issued_at: timestamptz_comparison_exp
  email_confirmed: Boolean_comparison_exp
  email_confirmed_at: timestamptz_comparison_exp
  id: String_comparison_exp
  last_seen: timestamptz_comparison_exp
  medias: media_bool_exp
  medias_aggregate: media_aggregate_bool_exp
  messages: message_bool_exp
  messages_aggregate: message_aggregate_bool_exp
  registered_at: timestamptz_comparison_exp
  role: role_enum_comparison_exp
  tag: tag_bool_exp
  tag_aggregate: tag_aggregate_bool_exp
  tasks_fixed_time: task_fixed_time_bool_exp
  tasks_fixed_time_aggregate: task_fixed_time_aggregate_bool_exp
  tasks_rss: task_rss_bool_exp
  tasks_rss_aggregate: task_rss_aggregate_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  active: Boolean
  email: String
  email_confirm_code: String
  email_confirm_code_issued_at: timestamptz
  email_confirmed: Boolean
  email_confirmed_at: timestamptz
  id: String
  last_seen: timestamptz
  medias: media_arr_rel_insert_input
  messages: message_arr_rel_insert_input
  registered_at: timestamptz
  role: role_enum
  tag: tag_arr_rel_insert_input
  tasks_fixed_time: task_fixed_time_arr_rel_insert_input
  tasks_rss: task_rss_arr_rel_insert_input
}

"""aggregate max on columns"""
type user_max_fields {
  email: String
  email_confirm_code: String
  email_confirm_code_issued_at: timestamptz
  email_confirmed_at: timestamptz
  id: String
  last_seen: timestamptz
  registered_at: timestamptz
}

"""aggregate min on columns"""
type user_min_fields {
  email: String
  email_confirm_code: String
  email_confirm_code_issued_at: timestamptz
  email_confirmed_at: timestamptz
  id: String
  last_seen: timestamptz
  registered_at: timestamptz
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  active: order_by
  email: order_by
  email_confirm_code: order_by
  email_confirm_code_issued_at: order_by
  email_confirmed: order_by
  email_confirmed_at: order_by
  id: order_by
  last_seen: order_by
  medias_aggregate: media_aggregate_order_by
  messages_aggregate: message_aggregate_order_by
  registered_at: order_by
  role: order_by
  tag_aggregate: tag_aggregate_order_by
  tasks_fixed_time_aggregate: task_fixed_time_aggregate_order_by
  tasks_rss_aggregate: task_rss_aggregate_order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: String!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  active

  """column name"""
  email

  """column name"""
  email_confirm_code

  """column name"""
  email_confirm_code_issued_at

  """column name"""
  email_confirmed

  """column name"""
  email_confirmed_at

  """column name"""
  id

  """column name"""
  last_seen

  """column name"""
  registered_at

  """column name"""
  role
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  active: Boolean
  email: String
  email_confirm_code: String
  email_confirm_code_issued_at: timestamptz
  email_confirmed: Boolean
  email_confirmed_at: timestamptz
  id: String
  last_seen: timestamptz
  registered_at: timestamptz
  role: role_enum
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  active: Boolean
  email: String
  email_confirm_code: String
  email_confirm_code_issued_at: timestamptz
  email_confirmed: Boolean
  email_confirmed_at: timestamptz
  id: String
  last_seen: timestamptz
  registered_at: timestamptz
  role: role_enum
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  active

  """column name"""
  email

  """column name"""
  email_confirm_code

  """column name"""
  email_confirm_code_issued_at

  """column name"""
  email_confirmed

  """column name"""
  email_confirmed_at

  """column name"""
  id

  """column name"""
  last_seen

  """column name"""
  registered_at

  """column name"""
  role
}

input user_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

