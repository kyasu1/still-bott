-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.Subscription exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Media_select_column
import Hasura.Enum.Message_select_column
import Hasura.Enum.Role_select_column
import Hasura.Enum.Session_select_column
import Hasura.Enum.Tag_select_column
import Hasura.Enum.Task_fixed_time_select_column
import Hasura.Enum.Task_rss_select_column
import Hasura.Enum.User_select_column
import Hasura.InputObject
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.Union
import Json.Decode as Decode exposing (Decoder)
import ScalarCodecs


type alias MediaOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Media_select_column.Media_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Media_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Media_bool_exp
    }


{-| fetch data from the table: "media"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
media :
    (MediaOptionalArguments -> MediaOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (List decodesTo) RootSubscription
media fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Media_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMedia_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMedia_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "media" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MediaAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Media_select_column.Media_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Media_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Media_bool_exp
    }


{-| fetch aggregated fields from the table: "media"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
media_aggregate :
    (MediaAggregateOptionalArguments -> MediaAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Media_aggregate
    -> SelectionSet decodesTo RootSubscription
media_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Media_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMedia_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMedia_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "media_aggregate" optionalArgs____ object____ Basics.identity


type alias MediaByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "media" using primary key columns
-}
media_by_pk :
    MediaByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (Maybe decodesTo) RootSubscription
media_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "media_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias MediaStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Media_bool_exp }


type alias MediaStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Media_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "media"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
media_stream :
    (MediaStreamOptionalArguments -> MediaStreamOptionalArguments)
    -> MediaStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (List decodesTo) RootSubscription
media_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMedia_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "media_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeMedia_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias MessageOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Message_select_column.Message_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Message_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Message_bool_exp
    }


{-| fetch data from the table: "message"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
message :
    (MessageOptionalArguments -> MessageOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (List decodesTo) RootSubscription
message fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Message_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMessage_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMessage_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "message" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MessageAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Message_select_column.Message_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Message_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Message_bool_exp
    }


{-| fetch aggregated fields from the table: "message"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
message_aggregate :
    (MessageAggregateOptionalArguments -> MessageAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Message_aggregate
    -> SelectionSet decodesTo RootSubscription
message_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Message_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMessage_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMessage_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "message_aggregate" optionalArgs____ object____ Basics.identity


type alias MessageByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "message" using primary key columns
-}
message_by_pk :
    MessageByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (Maybe decodesTo) RootSubscription
message_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "message_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias MessageStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Message_bool_exp }


type alias MessageStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Message_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "message"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
message_stream :
    (MessageStreamOptionalArguments -> MessageStreamOptionalArguments)
    -> MessageStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (List decodesTo) RootSubscription
message_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMessage_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "message_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeMessage_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias RoleOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Role_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Role_bool_exp
    }


{-| fetch data from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role :
    (RoleOptionalArguments -> RoleOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (List decodesTo) RootSubscription
role fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RoleAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Role_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Role_bool_exp
    }


{-| fetch aggregated fields from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role_aggregate :
    (RoleAggregateOptionalArguments -> RoleAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Role_aggregate
    -> SelectionSet decodesTo RootSubscription
role_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role_aggregate" optionalArgs____ object____ Basics.identity


type alias RoleByPkRequiredArguments =
    { value : String }


{-| fetch data from the table: "role" using primary key columns
-}
role_by_pk :
    RoleByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (Maybe decodesTo) RootSubscription
role_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "role_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RoleStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Role_bool_exp }


type alias RoleStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Role_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "role"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
role_stream :
    (RoleStreamOptionalArguments -> RoleStreamOptionalArguments)
    -> RoleStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (List decodesTo) RootSubscription
role_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeRole_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias SessionOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Session_select_column.Session_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Session_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Session_bool_exp
    }


{-| fetch data from the table: "session"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
session :
    (SessionOptionalArguments -> SessionOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (List decodesTo) RootSubscription
session fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Session_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeSession_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeSession_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "session" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias SessionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Session_select_column.Session_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Session_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Session_bool_exp
    }


{-| fetch aggregated fields from the table: "session"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
session_aggregate :
    (SessionAggregateOptionalArguments -> SessionAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Session_aggregate
    -> SelectionSet decodesTo RootSubscription
session_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Session_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeSession_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeSession_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "session_aggregate" optionalArgs____ object____ Basics.identity


type alias SessionByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "session" using primary key columns
-}
session_by_pk :
    SessionByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (Maybe decodesTo) RootSubscription
session_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "session_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias SessionStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Session_bool_exp }


type alias SessionStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Session_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "session"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
session_stream :
    (SessionStreamOptionalArguments -> SessionStreamOptionalArguments)
    -> SessionStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (List decodesTo) RootSubscription
session_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeSession_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "session_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeSession_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias TagOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Tag_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Tag_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag :
    (TagOptionalArguments -> TagOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (List decodesTo) RootSubscription
tag fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTag_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tag" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TagAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Tag_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Tag_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag_aggregate :
    (TagAggregateOptionalArguments -> TagAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Tag_aggregate
    -> SelectionSet decodesTo RootSubscription
tag_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTag_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tag_aggregate" optionalArgs____ object____ Basics.identity


type alias TagByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "tag" using primary key columns
-}
tag_by_pk :
    TagByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (Maybe decodesTo) RootSubscription
tag_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "tag_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias TagStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Tag_bool_exp }


type alias TagStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Tag_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "tag"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
tag_stream :
    (TagStreamOptionalArguments -> TagStreamOptionalArguments)
    -> TagStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (List decodesTo) RootSubscription
tag_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTag_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tag_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeTag_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias TaskFixedTimeOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_fixed_time_select_column.Task_fixed_time_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_fixed_time_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_fixed_time_bool_exp
    }


{-| fetch data from the table: "task\_fixed\_time"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_fixed_time :
    (TaskFixedTimeOptionalArguments -> TaskFixedTimeOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (List decodesTo) RootSubscription
task_fixed_time fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_fixed_time_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_fixed_time_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_fixed_time" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TaskFixedTimeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_fixed_time_select_column.Task_fixed_time_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_fixed_time_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_fixed_time_bool_exp
    }


{-| fetch aggregated fields from the table: "task\_fixed\_time"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_fixed_time_aggregate :
    (TaskFixedTimeAggregateOptionalArguments -> TaskFixedTimeAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time_aggregate
    -> SelectionSet decodesTo RootSubscription
task_fixed_time_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_fixed_time_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_fixed_time_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_fixed_time_aggregate" optionalArgs____ object____ Basics.identity


type alias TaskFixedTimeByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "task\_fixed\_time" using primary key columns
-}
task_fixed_time_by_pk :
    TaskFixedTimeByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (Maybe decodesTo) RootSubscription
task_fixed_time_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "task_fixed_time_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias TaskFixedTimeStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Task_fixed_time_bool_exp }


type alias TaskFixedTimeStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Task_fixed_time_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "task\_fixed\_time"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
task_fixed_time_stream :
    (TaskFixedTimeStreamOptionalArguments -> TaskFixedTimeStreamOptionalArguments)
    -> TaskFixedTimeStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (List decodesTo) RootSubscription
task_fixed_time_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_fixed_time_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeTask_fixed_time_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias TaskRssOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_rss_select_column.Task_rss_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_rss_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_rss_bool_exp
    }


{-| fetch data from the table: "task\_rss"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_rss :
    (TaskRssOptionalArguments -> TaskRssOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (List decodesTo) RootSubscription
task_rss fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_rss_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_rss_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_rss" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TaskRssAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_rss_select_column.Task_rss_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_rss_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_rss_bool_exp
    }


{-| fetch aggregated fields from the table: "task\_rss"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_rss_aggregate :
    (TaskRssAggregateOptionalArguments -> TaskRssAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_rss_aggregate
    -> SelectionSet decodesTo RootSubscription
task_rss_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_rss_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_rss_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_rss_aggregate" optionalArgs____ object____ Basics.identity


type alias TaskRssByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "task\_rss" using primary key columns
-}
task_rss_by_pk :
    TaskRssByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (Maybe decodesTo) RootSubscription
task_rss_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "task_rss_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias TaskRssStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.Task_rss_bool_exp }


type alias TaskRssStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.Task_rss_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "task\_rss"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
task_rss_stream :
    (TaskRssStreamOptionalArguments -> TaskRssStreamOptionalArguments)
    -> TaskRssStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (List decodesTo) RootSubscription
task_rss_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_rss_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeTask_rss_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)


type alias UserOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.User_select_column.User_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.User_order_by)
    , where_ : OptionalArgument Hasura.InputObject.User_bool_exp
    }


{-| fetch data from the table: "user"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
user :
    (UserOptionalArguments -> UserOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (List decodesTo) RootSubscription
user fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.User_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeUser_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeUser_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "user" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias UserAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.User_select_column.User_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.User_order_by)
    , where_ : OptionalArgument Hasura.InputObject.User_bool_exp
    }


{-| fetch aggregated fields from the table: "user"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
user_aggregate :
    (UserAggregateOptionalArguments -> UserAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.User_aggregate
    -> SelectionSet decodesTo RootSubscription
user_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.User_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeUser_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeUser_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "user_aggregate" optionalArgs____ object____ Basics.identity


type alias UserByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "user" using primary key columns
-}
user_by_pk :
    UserByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (Maybe decodesTo) RootSubscription
user_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "user_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias UserStreamOptionalArguments =
    { where_ : OptionalArgument Hasura.InputObject.User_bool_exp }


type alias UserStreamRequiredArguments =
    { batch_size : Int
    , cursor : List (Maybe Hasura.InputObject.User_stream_cursor_input)
    }


{-| fetch data from the table in a streaming manner: "user"

  - batch\_size - maximum number of rows returned in a single batch
  - cursor - cursor to stream the results returned by the query
  - where\_ - filter the rows returned

-}
user_stream :
    (UserStreamOptionalArguments -> UserStreamOptionalArguments)
    -> UserStreamRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (List decodesTo) RootSubscription
user_stream fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeUser_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "user_stream" (optionalArgs____ ++ [ Argument.required "batch_size" requiredArgs____.batch_size Encode.int, Argument.required "cursor" requiredArgs____.cursor (Hasura.InputObject.encodeUser_stream_cursor_input |> Encode.maybe |> Encode.list) ]) object____ (Basics.identity >> Decode.list)
