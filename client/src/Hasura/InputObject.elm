-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Cursor_ordering
import Hasura.Enum.Media_constraint
import Hasura.Enum.Media_select_column
import Hasura.Enum.Media_update_column
import Hasura.Enum.Message_constraint
import Hasura.Enum.Message_select_column
import Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns
import Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns
import Hasura.Enum.Message_update_column
import Hasura.Enum.Order_by
import Hasura.Enum.Role_constraint
import Hasura.Enum.Role_enum
import Hasura.Enum.Role_update_column
import Hasura.Enum.Session_constraint
import Hasura.Enum.Session_update_column
import Hasura.Enum.Tag_constraint
import Hasura.Enum.Tag_select_column
import Hasura.Enum.Tag_update_column
import Hasura.Enum.Task_fixed_time_constraint
import Hasura.Enum.Task_fixed_time_select_column
import Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns
import Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns
import Hasura.Enum.Task_fixed_time_update_column
import Hasura.Enum.Task_rss_constraint
import Hasura.Enum.Task_rss_select_column
import Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns
import Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns
import Hasura.Enum.Task_rss_update_column
import Hasura.Enum.User_constraint
import Hasura.Enum.User_update_column
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.Union
import Json.Decode as Decode
import ScalarCodecs


buildBooleanInput :
    BooleanInputRequiredFields
    -> BooleanInput
buildBooleanInput required____ =
    { dummy = required____.dummy }


type alias BooleanInputRequiredFields =
    { dummy : Bool }


{-| Type for the BooleanInput input object.
-}
type alias BooleanInput =
    { dummy : Bool }


{-| Encode a BooleanInput into a value that can be used as an argument.
-}
encodeBooleanInput : BooleanInput -> Value
encodeBooleanInput input____ =
    Encode.maybeObject
        [ ( "dummy", Encode.bool input____.dummy |> Just ) ]


buildBoolean_comparison_exp :
    (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields)
    -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List Bool)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List Bool)
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input____.eq_ ), ( "_gt", Encode.bool |> Encode.optional input____.gt_ ), ( "_gte", Encode.bool |> Encode.optional input____.gte_ ), ( "_in", (Encode.bool |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input____.lt_ ), ( "_lte", Encode.bool |> Encode.optional input____.lte_ ), ( "_neq", Encode.bool |> Encode.optional input____.neq_ ), ( "_nin", (Encode.bool |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildConfirmEmailInput :
    ConfirmEmailInputRequiredFields
    -> ConfirmEmailInput
buildConfirmEmailInput required____ =
    { code = required____.code, email = required____.email }


type alias ConfirmEmailInputRequiredFields =
    { code : String
    , email : String
    }


{-| Type for the ConfirmEmailInput input object.
-}
type alias ConfirmEmailInput =
    { code : String
    , email : String
    }


{-| Encode a ConfirmEmailInput into a value that can be used as an argument.
-}
encodeConfirmEmailInput : ConfirmEmailInput -> Value
encodeConfirmEmailInput input____ =
    Encode.maybeObject
        [ ( "code", Encode.string input____.code |> Just ), ( "email", Encode.string input____.email |> Just ) ]


buildDeleteImageInput :
    DeleteImageInputRequiredFields
    -> DeleteImageInput
buildDeleteImageInput required____ =
    { mediaId = required____.mediaId }


type alias DeleteImageInputRequiredFields =
    { mediaId : ScalarCodecs.Uuid }


{-| Type for the DeleteImageInput input object.
-}
type alias DeleteImageInput =
    { mediaId : ScalarCodecs.Uuid }


{-| Encode a DeleteImageInput into a value that can be used as an argument.
-}
encodeDeleteImageInput : DeleteImageInput -> Value
encodeDeleteImageInput input____ =
    Encode.maybeObject
        [ ( "mediaId", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.mediaId |> Just ) ]


buildInt_comparison_exp :
    (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields)
    -> Int_comparison_exp
buildInt_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input____.eq_ ), ( "_gt", Encode.int |> Encode.optional input____.gt_ ), ( "_gte", Encode.int |> Encode.optional input____.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.int |> Encode.optional input____.lt_ ), ( "_lte", Encode.int |> Encode.optional input____.lte_ ), ( "_neq", Encode.int |> Encode.optional input____.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildMedia_aggregate_bool_exp :
    (Media_aggregate_bool_expOptionalFields -> Media_aggregate_bool_expOptionalFields)
    -> Media_aggregate_bool_exp
buildMedia_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Media_aggregate_bool_exp { count = optionals____.count }


type alias Media_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Media_aggregate_bool_exp_count }


{-| Type alias for the `Media_aggregate_bool_exp` attributes. Note that this type
needs to use the `Media_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_aggregate_bool_expRaw =
    { count : OptionalArgument Media_aggregate_bool_exp_count }


{-| Type for the Media\_aggregate\_bool\_exp input object.
-}
type Media_aggregate_bool_exp
    = Media_aggregate_bool_exp Media_aggregate_bool_expRaw


{-| Encode a Media\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeMedia_aggregate_bool_exp : Media_aggregate_bool_exp -> Value
encodeMedia_aggregate_bool_exp (Media_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeMedia_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildMedia_aggregate_bool_exp_count :
    Media_aggregate_bool_exp_countRequiredFields
    -> (Media_aggregate_bool_exp_countOptionalFields -> Media_aggregate_bool_exp_countOptionalFields)
    -> Media_aggregate_bool_exp_count
buildMedia_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Media_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Media_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Media_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Hasura.Enum.Media_select_column.Media_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Media_bool_exp
    }


{-| Type alias for the `Media_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Media_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Hasura.Enum.Media_select_column.Media_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Media_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Media\_aggregate\_bool\_exp\_count input object.
-}
type Media_aggregate_bool_exp_count
    = Media_aggregate_bool_exp_count Media_aggregate_bool_exp_countRaw


{-| Encode a Media\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeMedia_aggregate_bool_exp_count : Media_aggregate_bool_exp_count -> Value
encodeMedia_aggregate_bool_exp_count (Media_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Hasura.Enum.Media_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeMedia_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildMedia_aggregate_order_by :
    (Media_aggregate_order_byOptionalFields -> Media_aggregate_order_byOptionalFields)
    -> Media_aggregate_order_by
buildMedia_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Media_aggregate_order_byOptionalFields =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Media_max_order_by
    , min : OptionalArgument Media_min_order_by
    }


{-| Type for the Media\_aggregate\_order\_by input object.
-}
type alias Media_aggregate_order_by =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Media_max_order_by
    , min : OptionalArgument Media_min_order_by
    }


{-| Encode a Media\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeMedia_aggregate_order_by : Media_aggregate_order_by -> Value
encodeMedia_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeMedia_max_order_by |> Encode.optional input____.max ), ( "min", encodeMedia_min_order_by |> Encode.optional input____.min ) ]


buildMedia_arr_rel_insert_input :
    Media_arr_rel_insert_inputRequiredFields
    -> (Media_arr_rel_insert_inputOptionalFields -> Media_arr_rel_insert_inputOptionalFields)
    -> Media_arr_rel_insert_input
buildMedia_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Media_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Media_arr_rel_insert_inputRequiredFields =
    { data : List Media_insert_input }


type alias Media_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Media_on_conflict }


{-| Type alias for the `Media_arr_rel_insert_input` attributes. Note that this type
needs to use the `Media_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_arr_rel_insert_inputRaw =
    { data : List Media_insert_input
    , on_conflict : OptionalArgument Media_on_conflict
    }


{-| Type for the Media\_arr\_rel\_insert\_input input object.
-}
type Media_arr_rel_insert_input
    = Media_arr_rel_insert_input Media_arr_rel_insert_inputRaw


{-| Encode a Media\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeMedia_arr_rel_insert_input : Media_arr_rel_insert_input -> Value
encodeMedia_arr_rel_insert_input (Media_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeMedia_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeMedia_on_conflict |> Encode.optional input____.on_conflict ) ]


buildMedia_bool_exp :
    (Media_bool_expOptionalFields -> Media_bool_expOptionalFields)
    -> Media_bool_exp
buildMedia_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, messages = Absent, messages_aggregate = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    Media_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, id = optionals____.id, messages = optionals____.messages, messages_aggregate = optionals____.messages_aggregate, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_bool_expOptionalFields =
    { and_ : OptionalArgument (List Media_bool_exp)
    , not_ : OptionalArgument Media_bool_exp
    , or_ : OptionalArgument (List Media_bool_exp)
    , id : OptionalArgument Uuid_comparison_exp
    , messages : OptionalArgument Message_bool_exp
    , messages_aggregate : OptionalArgument Message_aggregate_bool_exp
    , thumbnail : OptionalArgument String_comparison_exp
    , uploaded_at : OptionalArgument Timestamptz_comparison_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Media_bool_exp` attributes. Note that this type
needs to use the `Media_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_bool_expRaw =
    { and_ : OptionalArgument (List Media_bool_exp)
    , not_ : OptionalArgument Media_bool_exp
    , or_ : OptionalArgument (List Media_bool_exp)
    , id : OptionalArgument Uuid_comparison_exp
    , messages : OptionalArgument Message_bool_exp
    , messages_aggregate : OptionalArgument Message_aggregate_bool_exp
    , thumbnail : OptionalArgument String_comparison_exp
    , uploaded_at : OptionalArgument Timestamptz_comparison_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type for the Media\_bool\_exp input object.
-}
type Media_bool_exp
    = Media_bool_exp Media_bool_expRaw


{-| Encode a Media\_bool\_exp into a value that can be used as an argument.
-}
encodeMedia_bool_exp : Media_bool_exp -> Value
encodeMedia_bool_exp (Media_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeMedia_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeMedia_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeMedia_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "messages", encodeMessage_bool_exp |> Encode.optional input____.messages ), ( "messages_aggregate", encodeMessage_aggregate_bool_exp |> Encode.optional input____.messages_aggregate ), ( "thumbnail", encodeString_comparison_exp |> Encode.optional input____.thumbnail ), ( "uploaded_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.uploaded_at ), ( "user_id", encodeString_comparison_exp |> Encode.optional input____.user_id ) ]


buildMedia_insert_input :
    (Media_insert_inputOptionalFields -> Media_insert_inputOptionalFields)
    -> Media_insert_input
buildMedia_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, messages = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    Media_insert_input { id = optionals____.id, messages = optionals____.messages, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_insert_inputOptionalFields =
    { id : OptionalArgument ScalarCodecs.Uuid
    , messages : OptionalArgument Message_arr_rel_insert_input
    , thumbnail : OptionalArgument String
    , uploaded_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Type alias for the `Media_insert_input` attributes. Note that this type
needs to use the `Media_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_insert_inputRaw =
    { id : OptionalArgument ScalarCodecs.Uuid
    , messages : OptionalArgument Message_arr_rel_insert_input
    , thumbnail : OptionalArgument String
    , uploaded_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Type for the Media\_insert\_input input object.
-}
type Media_insert_input
    = Media_insert_input Media_insert_inputRaw


{-| Encode a Media\_insert\_input into a value that can be used as an argument.
-}
encodeMedia_insert_input : Media_insert_input -> Value
encodeMedia_insert_input (Media_insert_input input____) =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "messages", encodeMessage_arr_rel_insert_input |> Encode.optional input____.messages ), ( "thumbnail", Encode.string |> Encode.optional input____.thumbnail ), ( "uploaded_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.uploaded_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildMedia_max_order_by :
    (Media_max_order_byOptionalFields -> Media_max_order_byOptionalFields)
    -> Media_max_order_by
buildMedia_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    { id = optionals____.id, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_max_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thumbnail : OptionalArgument Hasura.Enum.Order_by.Order_by
    , uploaded_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Media\_max\_order\_by input object.
-}
type alias Media_max_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thumbnail : OptionalArgument Hasura.Enum.Order_by.Order_by
    , uploaded_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Media\_max\_order\_by into a value that can be used as an argument.
-}
encodeMedia_max_order_by : Media_max_order_by -> Value
encodeMedia_max_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "thumbnail", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.thumbnail ), ( "uploaded_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.uploaded_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildMedia_min_order_by :
    (Media_min_order_byOptionalFields -> Media_min_order_byOptionalFields)
    -> Media_min_order_by
buildMedia_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    { id = optionals____.id, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_min_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thumbnail : OptionalArgument Hasura.Enum.Order_by.Order_by
    , uploaded_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Media\_min\_order\_by input object.
-}
type alias Media_min_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thumbnail : OptionalArgument Hasura.Enum.Order_by.Order_by
    , uploaded_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Media\_min\_order\_by into a value that can be used as an argument.
-}
encodeMedia_min_order_by : Media_min_order_by -> Value
encodeMedia_min_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "thumbnail", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.thumbnail ), ( "uploaded_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.uploaded_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildMedia_obj_rel_insert_input :
    Media_obj_rel_insert_inputRequiredFields
    -> (Media_obj_rel_insert_inputOptionalFields -> Media_obj_rel_insert_inputOptionalFields)
    -> Media_obj_rel_insert_input
buildMedia_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Media_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Media_obj_rel_insert_inputRequiredFields =
    { data : Media_insert_input }


type alias Media_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Media_on_conflict }


{-| Type alias for the `Media_obj_rel_insert_input` attributes. Note that this type
needs to use the `Media_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_obj_rel_insert_inputRaw =
    { data : Media_insert_input
    , on_conflict : OptionalArgument Media_on_conflict
    }


{-| Type for the Media\_obj\_rel\_insert\_input input object.
-}
type Media_obj_rel_insert_input
    = Media_obj_rel_insert_input Media_obj_rel_insert_inputRaw


{-| Encode a Media\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeMedia_obj_rel_insert_input : Media_obj_rel_insert_input -> Value
encodeMedia_obj_rel_insert_input (Media_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeMedia_insert_input input____.data |> Just ), ( "on_conflict", encodeMedia_on_conflict |> Encode.optional input____.on_conflict ) ]


buildMedia_on_conflict :
    Media_on_conflictRequiredFields
    -> (Media_on_conflictOptionalFields -> Media_on_conflictOptionalFields)
    -> Media_on_conflict
buildMedia_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Media_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Media_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Media_constraint.Media_constraint
    , update_columns : List Hasura.Enum.Media_update_column.Media_update_column
    }


type alias Media_on_conflictOptionalFields =
    { where_ : OptionalArgument Media_bool_exp }


{-| Type alias for the `Media_on_conflict` attributes. Note that this type
needs to use the `Media_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_on_conflictRaw =
    { constraint : Hasura.Enum.Media_constraint.Media_constraint
    , update_columns : List Hasura.Enum.Media_update_column.Media_update_column
    , where_ : OptionalArgument Media_bool_exp
    }


{-| Type for the Media\_on\_conflict input object.
-}
type Media_on_conflict
    = Media_on_conflict Media_on_conflictRaw


{-| Encode a Media\_on\_conflict into a value that can be used as an argument.
-}
encodeMedia_on_conflict : Media_on_conflict -> Value
encodeMedia_on_conflict (Media_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Media_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Media_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeMedia_bool_exp |> Encode.optional input____.where_ ) ]


buildMedia_order_by :
    (Media_order_byOptionalFields -> Media_order_byOptionalFields)
    -> Media_order_by
buildMedia_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, messages_aggregate = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    { id = optionals____.id, messages_aggregate = optionals____.messages_aggregate, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , messages_aggregate : OptionalArgument Message_aggregate_order_by
    , thumbnail : OptionalArgument Hasura.Enum.Order_by.Order_by
    , uploaded_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Media\_order\_by input object.
-}
type alias Media_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , messages_aggregate : OptionalArgument Message_aggregate_order_by
    , thumbnail : OptionalArgument Hasura.Enum.Order_by.Order_by
    , uploaded_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Media\_order\_by into a value that can be used as an argument.
-}
encodeMedia_order_by : Media_order_by -> Value
encodeMedia_order_by input____ =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "messages_aggregate", encodeMessage_aggregate_order_by |> Encode.optional input____.messages_aggregate ), ( "thumbnail", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.thumbnail ), ( "uploaded_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.uploaded_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildMedia_pk_columns_input :
    Media_pk_columns_inputRequiredFields
    -> Media_pk_columns_input
buildMedia_pk_columns_input required____ =
    { id = required____.id }


type alias Media_pk_columns_inputRequiredFields =
    { id : ScalarCodecs.Uuid }


{-| Type for the Media\_pk\_columns\_input input object.
-}
type alias Media_pk_columns_input =
    { id : ScalarCodecs.Uuid }


{-| Encode a Media\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeMedia_pk_columns_input : Media_pk_columns_input -> Value
encodeMedia_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildMedia_set_input :
    (Media_set_inputOptionalFields -> Media_set_inputOptionalFields)
    -> Media_set_input
buildMedia_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    { id = optionals____.id, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_set_inputOptionalFields =
    { id : OptionalArgument ScalarCodecs.Uuid
    , thumbnail : OptionalArgument String
    , uploaded_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Type for the Media\_set\_input input object.
-}
type alias Media_set_input =
    { id : OptionalArgument ScalarCodecs.Uuid
    , thumbnail : OptionalArgument String
    , uploaded_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Encode a Media\_set\_input into a value that can be used as an argument.
-}
encodeMedia_set_input : Media_set_input -> Value
encodeMedia_set_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "thumbnail", Encode.string |> Encode.optional input____.thumbnail ), ( "uploaded_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.uploaded_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildMedia_stream_cursor_input :
    Media_stream_cursor_inputRequiredFields
    -> (Media_stream_cursor_inputOptionalFields -> Media_stream_cursor_inputOptionalFields)
    -> Media_stream_cursor_input
buildMedia_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Media_stream_cursor_inputRequiredFields =
    { initial_value : Media_stream_cursor_value_input }


type alias Media_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Media\_stream\_cursor\_input input object.
-}
type alias Media_stream_cursor_input =
    { initial_value : Media_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Media\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeMedia_stream_cursor_input : Media_stream_cursor_input -> Value
encodeMedia_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeMedia_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildMedia_stream_cursor_value_input :
    (Media_stream_cursor_value_inputOptionalFields -> Media_stream_cursor_value_inputOptionalFields)
    -> Media_stream_cursor_value_input
buildMedia_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { id = Absent, thumbnail = Absent, uploaded_at = Absent, user_id = Absent }
    in
    { id = optionals____.id, thumbnail = optionals____.thumbnail, uploaded_at = optionals____.uploaded_at, user_id = optionals____.user_id }


type alias Media_stream_cursor_value_inputOptionalFields =
    { id : OptionalArgument ScalarCodecs.Uuid
    , thumbnail : OptionalArgument String
    , uploaded_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Type for the Media\_stream\_cursor\_value\_input input object.
-}
type alias Media_stream_cursor_value_input =
    { id : OptionalArgument ScalarCodecs.Uuid
    , thumbnail : OptionalArgument String
    , uploaded_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Encode a Media\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeMedia_stream_cursor_value_input : Media_stream_cursor_value_input -> Value
encodeMedia_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "thumbnail", Encode.string |> Encode.optional input____.thumbnail ), ( "uploaded_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.uploaded_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildMedia_updates :
    Media_updatesRequiredFields
    -> (Media_updatesOptionalFields -> Media_updatesOptionalFields)
    -> Media_updates
buildMedia_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Media_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Media_updatesRequiredFields =
    { where_ : Media_bool_exp }


type alias Media_updatesOptionalFields =
    { set_ : OptionalArgument Media_set_input }


{-| Type alias for the `Media_updates` attributes. Note that this type
needs to use the `Media_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Media_updatesRaw =
    { set_ : OptionalArgument Media_set_input
    , where_ : Media_bool_exp
    }


{-| Type for the Media\_updates input object.
-}
type Media_updates
    = Media_updates Media_updatesRaw


{-| Encode a Media\_updates into a value that can be used as an argument.
-}
encodeMedia_updates : Media_updates -> Value
encodeMedia_updates (Media_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeMedia_set_input |> Encode.optional input____.set_ ), ( "where", encodeMedia_bool_exp input____.where_ |> Just ) ]


buildMessage_aggregate_bool_exp :
    (Message_aggregate_bool_expOptionalFields -> Message_aggregate_bool_expOptionalFields)
    -> Message_aggregate_bool_exp
buildMessage_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { bool_and = Absent, bool_or = Absent, count = Absent }
    in
    Message_aggregate_bool_exp { bool_and = optionals____.bool_and, bool_or = optionals____.bool_or, count = optionals____.count }


type alias Message_aggregate_bool_expOptionalFields =
    { bool_and : OptionalArgument Message_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Message_aggregate_bool_exp_bool_or
    , count : OptionalArgument Message_aggregate_bool_exp_count
    }


{-| Type alias for the `Message_aggregate_bool_exp` attributes. Note that this type
needs to use the `Message_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_aggregate_bool_expRaw =
    { bool_and : OptionalArgument Message_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Message_aggregate_bool_exp_bool_or
    , count : OptionalArgument Message_aggregate_bool_exp_count
    }


{-| Type for the Message\_aggregate\_bool\_exp input object.
-}
type Message_aggregate_bool_exp
    = Message_aggregate_bool_exp Message_aggregate_bool_expRaw


{-| Encode a Message\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeMessage_aggregate_bool_exp : Message_aggregate_bool_exp -> Value
encodeMessage_aggregate_bool_exp (Message_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "bool_and", encodeMessage_aggregate_bool_exp_bool_and |> Encode.optional input____.bool_and ), ( "bool_or", encodeMessage_aggregate_bool_exp_bool_or |> Encode.optional input____.bool_or ), ( "count", encodeMessage_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildMessage_aggregate_bool_exp_bool_and :
    Message_aggregate_bool_exp_bool_andRequiredFields
    -> (Message_aggregate_bool_exp_bool_andOptionalFields -> Message_aggregate_bool_exp_bool_andOptionalFields)
    -> Message_aggregate_bool_exp_bool_and
buildMessage_aggregate_bool_exp_bool_and required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Message_aggregate_bool_exp_bool_and { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Message_aggregate_bool_exp_bool_andRequiredFields =
    { arguments : Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns.Message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Message_aggregate_bool_exp_bool_andOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Message_bool_exp
    }


{-| Type alias for the `Message_aggregate_bool_exp_bool_and` attributes. Note that this type
needs to use the `Message_aggregate_bool_exp_bool_and` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_aggregate_bool_exp_bool_andRaw =
    { arguments : Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns.Message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Message_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Message\_aggregate\_bool\_exp\_bool\_and input object.
-}
type Message_aggregate_bool_exp_bool_and
    = Message_aggregate_bool_exp_bool_and Message_aggregate_bool_exp_bool_andRaw


{-| Encode a Message\_aggregate\_bool\_exp\_bool\_and into a value that can be used as an argument.
-}
encodeMessage_aggregate_bool_exp_bool_and : Message_aggregate_bool_exp_bool_and -> Value
encodeMessage_aggregate_bool_exp_bool_and (Message_aggregate_bool_exp_bool_and input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeMessage_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildMessage_aggregate_bool_exp_bool_or :
    Message_aggregate_bool_exp_bool_orRequiredFields
    -> (Message_aggregate_bool_exp_bool_orOptionalFields -> Message_aggregate_bool_exp_bool_orOptionalFields)
    -> Message_aggregate_bool_exp_bool_or
buildMessage_aggregate_bool_exp_bool_or required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Message_aggregate_bool_exp_bool_or { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Message_aggregate_bool_exp_bool_orRequiredFields =
    { arguments : Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns.Message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Message_aggregate_bool_exp_bool_orOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Message_bool_exp
    }


{-| Type alias for the `Message_aggregate_bool_exp_bool_or` attributes. Note that this type
needs to use the `Message_aggregate_bool_exp_bool_or` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_aggregate_bool_exp_bool_orRaw =
    { arguments : Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns.Message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Message_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Message\_aggregate\_bool\_exp\_bool\_or input object.
-}
type Message_aggregate_bool_exp_bool_or
    = Message_aggregate_bool_exp_bool_or Message_aggregate_bool_exp_bool_orRaw


{-| Encode a Message\_aggregate\_bool\_exp\_bool\_or into a value that can be used as an argument.
-}
encodeMessage_aggregate_bool_exp_bool_or : Message_aggregate_bool_exp_bool_or -> Value
encodeMessage_aggregate_bool_exp_bool_or (Message_aggregate_bool_exp_bool_or input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum Hasura.Enum.Message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeMessage_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildMessage_aggregate_bool_exp_count :
    Message_aggregate_bool_exp_countRequiredFields
    -> (Message_aggregate_bool_exp_countOptionalFields -> Message_aggregate_bool_exp_countOptionalFields)
    -> Message_aggregate_bool_exp_count
buildMessage_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Message_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Message_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Message_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Hasura.Enum.Message_select_column.Message_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Message_bool_exp
    }


{-| Type alias for the `Message_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Message_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Hasura.Enum.Message_select_column.Message_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Message_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Message\_aggregate\_bool\_exp\_count input object.
-}
type Message_aggregate_bool_exp_count
    = Message_aggregate_bool_exp_count Message_aggregate_bool_exp_countRaw


{-| Encode a Message\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeMessage_aggregate_bool_exp_count : Message_aggregate_bool_exp_count -> Value
encodeMessage_aggregate_bool_exp_count (Message_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Hasura.Enum.Message_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeMessage_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildMessage_aggregate_order_by :
    (Message_aggregate_order_byOptionalFields -> Message_aggregate_order_byOptionalFields)
    -> Message_aggregate_order_by
buildMessage_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals____.avg, count = optionals____.count, max = optionals____.max, min = optionals____.min, stddev = optionals____.stddev, stddev_pop = optionals____.stddev_pop, stddev_samp = optionals____.stddev_samp, sum = optionals____.sum, var_pop = optionals____.var_pop, var_samp = optionals____.var_samp, variance = optionals____.variance }


type alias Message_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Message_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Message_max_order_by
    , min : OptionalArgument Message_min_order_by
    , stddev : OptionalArgument Message_stddev_order_by
    , stddev_pop : OptionalArgument Message_stddev_pop_order_by
    , stddev_samp : OptionalArgument Message_stddev_samp_order_by
    , sum : OptionalArgument Message_sum_order_by
    , var_pop : OptionalArgument Message_var_pop_order_by
    , var_samp : OptionalArgument Message_var_samp_order_by
    , variance : OptionalArgument Message_variance_order_by
    }


{-| Type for the Message\_aggregate\_order\_by input object.
-}
type alias Message_aggregate_order_by =
    { avg : OptionalArgument Message_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Message_max_order_by
    , min : OptionalArgument Message_min_order_by
    , stddev : OptionalArgument Message_stddev_order_by
    , stddev_pop : OptionalArgument Message_stddev_pop_order_by
    , stddev_samp : OptionalArgument Message_stddev_samp_order_by
    , sum : OptionalArgument Message_sum_order_by
    , var_pop : OptionalArgument Message_var_pop_order_by
    , var_samp : OptionalArgument Message_var_samp_order_by
    , variance : OptionalArgument Message_variance_order_by
    }


{-| Encode a Message\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeMessage_aggregate_order_by : Message_aggregate_order_by -> Value
encodeMessage_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "avg", encodeMessage_avg_order_by |> Encode.optional input____.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeMessage_max_order_by |> Encode.optional input____.max ), ( "min", encodeMessage_min_order_by |> Encode.optional input____.min ), ( "stddev", encodeMessage_stddev_order_by |> Encode.optional input____.stddev ), ( "stddev_pop", encodeMessage_stddev_pop_order_by |> Encode.optional input____.stddev_pop ), ( "stddev_samp", encodeMessage_stddev_samp_order_by |> Encode.optional input____.stddev_samp ), ( "sum", encodeMessage_sum_order_by |> Encode.optional input____.sum ), ( "var_pop", encodeMessage_var_pop_order_by |> Encode.optional input____.var_pop ), ( "var_samp", encodeMessage_var_samp_order_by |> Encode.optional input____.var_samp ), ( "variance", encodeMessage_variance_order_by |> Encode.optional input____.variance ) ]


buildMessage_arr_rel_insert_input :
    Message_arr_rel_insert_inputRequiredFields
    -> (Message_arr_rel_insert_inputOptionalFields -> Message_arr_rel_insert_inputOptionalFields)
    -> Message_arr_rel_insert_input
buildMessage_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Message_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Message_arr_rel_insert_inputRequiredFields =
    { data : List Message_insert_input }


type alias Message_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Message_on_conflict }


{-| Type alias for the `Message_arr_rel_insert_input` attributes. Note that this type
needs to use the `Message_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_arr_rel_insert_inputRaw =
    { data : List Message_insert_input
    , on_conflict : OptionalArgument Message_on_conflict
    }


{-| Type for the Message\_arr\_rel\_insert\_input input object.
-}
type Message_arr_rel_insert_input
    = Message_arr_rel_insert_input Message_arr_rel_insert_inputRaw


{-| Encode a Message\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeMessage_arr_rel_insert_input : Message_arr_rel_insert_input -> Value
encodeMessage_arr_rel_insert_input (Message_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeMessage_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeMessage_on_conflict |> Encode.optional input____.on_conflict ) ]


buildMessage_avg_order_by :
    (Message_avg_order_byOptionalFields -> Message_avg_order_byOptionalFields)
    -> Message_avg_order_by
buildMessage_avg_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_avg_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_avg\_order\_by input object.
-}
type alias Message_avg_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_avg\_order\_by into a value that can be used as an argument.
-}
encodeMessage_avg_order_by : Message_avg_order_by -> Value
encodeMessage_avg_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_bool_exp :
    (Message_bool_expOptionalFields -> Message_bool_expOptionalFields)
    -> Message_bool_exp
buildMessage_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, id = Absent, media = Absent, media_id = Absent, priority = Absent, tag = Absent, tag_id = Absent, text = Absent, tweeted = Absent, updated_at = Absent, user = Absent, user_id = Absent }
    in
    Message_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, created_at = optionals____.created_at, id = optionals____.id, media = optionals____.media, media_id = optionals____.media_id, priority = optionals____.priority, tag = optionals____.tag, tag_id = optionals____.tag_id, text = optionals____.text, tweeted = optionals____.tweeted, updated_at = optionals____.updated_at, user = optionals____.user, user_id = optionals____.user_id }


type alias Message_bool_expOptionalFields =
    { and_ : OptionalArgument (List Message_bool_exp)
    , not_ : OptionalArgument Message_bool_exp
    , or_ : OptionalArgument (List Message_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , media : OptionalArgument Media_bool_exp
    , media_id : OptionalArgument Uuid_comparison_exp
    , priority : OptionalArgument Int_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    , text : OptionalArgument String_comparison_exp
    , tweeted : OptionalArgument Boolean_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Message_bool_exp` attributes. Note that this type
needs to use the `Message_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_bool_expRaw =
    { and_ : OptionalArgument (List Message_bool_exp)
    , not_ : OptionalArgument Message_bool_exp
    , or_ : OptionalArgument (List Message_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , media : OptionalArgument Media_bool_exp
    , media_id : OptionalArgument Uuid_comparison_exp
    , priority : OptionalArgument Int_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    , text : OptionalArgument String_comparison_exp
    , tweeted : OptionalArgument Boolean_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type for the Message\_bool\_exp input object.
-}
type Message_bool_exp
    = Message_bool_exp Message_bool_expRaw


{-| Encode a Message\_bool\_exp into a value that can be used as an argument.
-}
encodeMessage_bool_exp : Message_bool_exp -> Value
encodeMessage_bool_exp (Message_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeMessage_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeMessage_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeMessage_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "media", encodeMedia_bool_exp |> Encode.optional input____.media ), ( "media_id", encodeUuid_comparison_exp |> Encode.optional input____.media_id ), ( "priority", encodeInt_comparison_exp |> Encode.optional input____.priority ), ( "tag", encodeTag_bool_exp |> Encode.optional input____.tag ), ( "tag_id", encodeUuid_comparison_exp |> Encode.optional input____.tag_id ), ( "text", encodeString_comparison_exp |> Encode.optional input____.text ), ( "tweeted", encodeBoolean_comparison_exp |> Encode.optional input____.tweeted ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ), ( "user", encodeUser_bool_exp |> Encode.optional input____.user ), ( "user_id", encodeString_comparison_exp |> Encode.optional input____.user_id ) ]


buildMessage_inc_input :
    (Message_inc_inputOptionalFields -> Message_inc_inputOptionalFields)
    -> Message_inc_input
buildMessage_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_inc_inputOptionalFields =
    { priority : OptionalArgument Int }


{-| Type for the Message\_inc\_input input object.
-}
type alias Message_inc_input =
    { priority : OptionalArgument Int }


{-| Encode a Message\_inc\_input into a value that can be used as an argument.
-}
encodeMessage_inc_input : Message_inc_input -> Value
encodeMessage_inc_input input____ =
    Encode.maybeObject
        [ ( "priority", Encode.int |> Encode.optional input____.priority ) ]


buildMessage_insert_input :
    (Message_insert_inputOptionalFields -> Message_insert_inputOptionalFields)
    -> Message_insert_input
buildMessage_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, media = Absent, media_id = Absent, priority = Absent, tag = Absent, tag_id = Absent, text = Absent, tweeted = Absent, updated_at = Absent, user = Absent, user_id = Absent }
    in
    Message_insert_input { created_at = optionals____.created_at, id = optionals____.id, media = optionals____.media, media_id = optionals____.media_id, priority = optionals____.priority, tag = optionals____.tag, tag_id = optionals____.tag_id, text = optionals____.text, tweeted = optionals____.tweeted, updated_at = optionals____.updated_at, user = optionals____.user, user_id = optionals____.user_id }


type alias Message_insert_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument ScalarCodecs.Uuid
    , media : OptionalArgument Media_obj_rel_insert_input
    , media_id : OptionalArgument ScalarCodecs.Uuid
    , priority : OptionalArgument Int
    , tag : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , text : OptionalArgument String
    , tweeted : OptionalArgument Bool
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    }


{-| Type alias for the `Message_insert_input` attributes. Note that this type
needs to use the `Message_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_insert_inputRaw =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument ScalarCodecs.Uuid
    , media : OptionalArgument Media_obj_rel_insert_input
    , media_id : OptionalArgument ScalarCodecs.Uuid
    , priority : OptionalArgument Int
    , tag : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , text : OptionalArgument String
    , tweeted : OptionalArgument Bool
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    }


{-| Type for the Message\_insert\_input input object.
-}
type Message_insert_input
    = Message_insert_input Message_insert_inputRaw


{-| Encode a Message\_insert\_input into a value that can be used as an argument.
-}
encodeMessage_insert_input : Message_insert_input -> Value
encodeMessage_insert_input (Message_insert_input input____) =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "media", encodeMedia_obj_rel_insert_input |> Encode.optional input____.media ), ( "media_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.media_id ), ( "priority", Encode.int |> Encode.optional input____.priority ), ( "tag", encodeTag_obj_rel_insert_input |> Encode.optional input____.tag ), ( "tag_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.tag_id ), ( "text", Encode.string |> Encode.optional input____.text ), ( "tweeted", Encode.bool |> Encode.optional input____.tweeted ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "user", encodeUser_obj_rel_insert_input |> Encode.optional input____.user ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildMessage_max_order_by :
    (Message_max_order_byOptionalFields -> Message_max_order_byOptionalFields)
    -> Message_max_order_by
buildMessage_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, media_id = Absent, priority = Absent, tag_id = Absent, text = Absent, updated_at = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, media_id = optionals____.media_id, priority = optionals____.priority, tag_id = optionals____.tag_id, text = optionals____.text, updated_at = optionals____.updated_at, user_id = optionals____.user_id }


type alias Message_max_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , media_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , priority : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , text : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Message\_max\_order\_by input object.
-}
type alias Message_max_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , media_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , priority : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , text : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Message\_max\_order\_by into a value that can be used as an argument.
-}
encodeMessage_max_order_by : Message_max_order_by -> Value
encodeMessage_max_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "media_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.media_id ), ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ), ( "tag_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tag_id ), ( "text", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.text ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildMessage_min_order_by :
    (Message_min_order_byOptionalFields -> Message_min_order_byOptionalFields)
    -> Message_min_order_by
buildMessage_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, media_id = Absent, priority = Absent, tag_id = Absent, text = Absent, updated_at = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, media_id = optionals____.media_id, priority = optionals____.priority, tag_id = optionals____.tag_id, text = optionals____.text, updated_at = optionals____.updated_at, user_id = optionals____.user_id }


type alias Message_min_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , media_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , priority : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , text : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Message\_min\_order\_by input object.
-}
type alias Message_min_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , media_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , priority : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , text : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Message\_min\_order\_by into a value that can be used as an argument.
-}
encodeMessage_min_order_by : Message_min_order_by -> Value
encodeMessage_min_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "media_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.media_id ), ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ), ( "tag_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tag_id ), ( "text", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.text ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildMessage_on_conflict :
    Message_on_conflictRequiredFields
    -> (Message_on_conflictOptionalFields -> Message_on_conflictOptionalFields)
    -> Message_on_conflict
buildMessage_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Message_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Message_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Message_constraint.Message_constraint
    , update_columns : List Hasura.Enum.Message_update_column.Message_update_column
    }


type alias Message_on_conflictOptionalFields =
    { where_ : OptionalArgument Message_bool_exp }


{-| Type alias for the `Message_on_conflict` attributes. Note that this type
needs to use the `Message_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_on_conflictRaw =
    { constraint : Hasura.Enum.Message_constraint.Message_constraint
    , update_columns : List Hasura.Enum.Message_update_column.Message_update_column
    , where_ : OptionalArgument Message_bool_exp
    }


{-| Type for the Message\_on\_conflict input object.
-}
type Message_on_conflict
    = Message_on_conflict Message_on_conflictRaw


{-| Encode a Message\_on\_conflict into a value that can be used as an argument.
-}
encodeMessage_on_conflict : Message_on_conflict -> Value
encodeMessage_on_conflict (Message_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Message_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Message_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeMessage_bool_exp |> Encode.optional input____.where_ ) ]


buildMessage_order_by :
    (Message_order_byOptionalFields -> Message_order_byOptionalFields)
    -> Message_order_by
buildMessage_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, media = Absent, media_id = Absent, priority = Absent, tag = Absent, tag_id = Absent, text = Absent, tweeted = Absent, updated_at = Absent, user = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, media = optionals____.media, media_id = optionals____.media_id, priority = optionals____.priority, tag = optionals____.tag, tag_id = optionals____.tag_id, text = optionals____.text, tweeted = optionals____.tweeted, updated_at = optionals____.updated_at, user = optionals____.user, user_id = optionals____.user_id }


type alias Message_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , media : OptionalArgument Media_order_by
    , media_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , priority : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , text : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tweeted : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Message\_order\_by input object.
-}
type alias Message_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , media : OptionalArgument Media_order_by
    , media_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , priority : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , text : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tweeted : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Message\_order\_by into a value that can be used as an argument.
-}
encodeMessage_order_by : Message_order_by -> Value
encodeMessage_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "media", encodeMedia_order_by |> Encode.optional input____.media ), ( "media_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.media_id ), ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ), ( "tag", encodeTag_order_by |> Encode.optional input____.tag ), ( "tag_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tag_id ), ( "text", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.text ), ( "tweeted", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tweeted ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "user", encodeUser_order_by |> Encode.optional input____.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildMessage_pk_columns_input :
    Message_pk_columns_inputRequiredFields
    -> Message_pk_columns_input
buildMessage_pk_columns_input required____ =
    { id = required____.id }


type alias Message_pk_columns_inputRequiredFields =
    { id : ScalarCodecs.Uuid }


{-| Type for the Message\_pk\_columns\_input input object.
-}
type alias Message_pk_columns_input =
    { id : ScalarCodecs.Uuid }


{-| Encode a Message\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeMessage_pk_columns_input : Message_pk_columns_input -> Value
encodeMessage_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildMessage_set_input :
    (Message_set_inputOptionalFields -> Message_set_inputOptionalFields)
    -> Message_set_input
buildMessage_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, media_id = Absent, priority = Absent, tag_id = Absent, text = Absent, tweeted = Absent, updated_at = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, media_id = optionals____.media_id, priority = optionals____.priority, tag_id = optionals____.tag_id, text = optionals____.text, tweeted = optionals____.tweeted, updated_at = optionals____.updated_at, user_id = optionals____.user_id }


type alias Message_set_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument ScalarCodecs.Uuid
    , media_id : OptionalArgument ScalarCodecs.Uuid
    , priority : OptionalArgument Int
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , text : OptionalArgument String
    , tweeted : OptionalArgument Bool
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Type for the Message\_set\_input input object.
-}
type alias Message_set_input =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument ScalarCodecs.Uuid
    , media_id : OptionalArgument ScalarCodecs.Uuid
    , priority : OptionalArgument Int
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , text : OptionalArgument String
    , tweeted : OptionalArgument Bool
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Encode a Message\_set\_input into a value that can be used as an argument.
-}
encodeMessage_set_input : Message_set_input -> Value
encodeMessage_set_input input____ =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "media_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.media_id ), ( "priority", Encode.int |> Encode.optional input____.priority ), ( "tag_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.tag_id ), ( "text", Encode.string |> Encode.optional input____.text ), ( "tweeted", Encode.bool |> Encode.optional input____.tweeted ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildMessage_stddev_order_by :
    (Message_stddev_order_byOptionalFields -> Message_stddev_order_byOptionalFields)
    -> Message_stddev_order_by
buildMessage_stddev_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_stddev_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_stddev\_order\_by input object.
-}
type alias Message_stddev_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeMessage_stddev_order_by : Message_stddev_order_by -> Value
encodeMessage_stddev_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_stddev_pop_order_by :
    (Message_stddev_pop_order_byOptionalFields -> Message_stddev_pop_order_byOptionalFields)
    -> Message_stddev_pop_order_by
buildMessage_stddev_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_stddev_pop_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_stddev\_pop\_order\_by input object.
-}
type alias Message_stddev_pop_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeMessage_stddev_pop_order_by : Message_stddev_pop_order_by -> Value
encodeMessage_stddev_pop_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_stddev_samp_order_by :
    (Message_stddev_samp_order_byOptionalFields -> Message_stddev_samp_order_byOptionalFields)
    -> Message_stddev_samp_order_by
buildMessage_stddev_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_stddev_samp_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_stddev\_samp\_order\_by input object.
-}
type alias Message_stddev_samp_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeMessage_stddev_samp_order_by : Message_stddev_samp_order_by -> Value
encodeMessage_stddev_samp_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_stream_cursor_input :
    Message_stream_cursor_inputRequiredFields
    -> (Message_stream_cursor_inputOptionalFields -> Message_stream_cursor_inputOptionalFields)
    -> Message_stream_cursor_input
buildMessage_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Message_stream_cursor_inputRequiredFields =
    { initial_value : Message_stream_cursor_value_input }


type alias Message_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Message\_stream\_cursor\_input input object.
-}
type alias Message_stream_cursor_input =
    { initial_value : Message_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Message\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeMessage_stream_cursor_input : Message_stream_cursor_input -> Value
encodeMessage_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeMessage_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildMessage_stream_cursor_value_input :
    (Message_stream_cursor_value_inputOptionalFields -> Message_stream_cursor_value_inputOptionalFields)
    -> Message_stream_cursor_value_input
buildMessage_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, media_id = Absent, priority = Absent, tag_id = Absent, text = Absent, tweeted = Absent, updated_at = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, media_id = optionals____.media_id, priority = optionals____.priority, tag_id = optionals____.tag_id, text = optionals____.text, tweeted = optionals____.tweeted, updated_at = optionals____.updated_at, user_id = optionals____.user_id }


type alias Message_stream_cursor_value_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument ScalarCodecs.Uuid
    , media_id : OptionalArgument ScalarCodecs.Uuid
    , priority : OptionalArgument Int
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , text : OptionalArgument String
    , tweeted : OptionalArgument Bool
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Type for the Message\_stream\_cursor\_value\_input input object.
-}
type alias Message_stream_cursor_value_input =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument ScalarCodecs.Uuid
    , media_id : OptionalArgument ScalarCodecs.Uuid
    , priority : OptionalArgument Int
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , text : OptionalArgument String
    , tweeted : OptionalArgument Bool
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    }


{-| Encode a Message\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeMessage_stream_cursor_value_input : Message_stream_cursor_value_input -> Value
encodeMessage_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "media_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.media_id ), ( "priority", Encode.int |> Encode.optional input____.priority ), ( "tag_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.tag_id ), ( "text", Encode.string |> Encode.optional input____.text ), ( "tweeted", Encode.bool |> Encode.optional input____.tweeted ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildMessage_sum_order_by :
    (Message_sum_order_byOptionalFields -> Message_sum_order_byOptionalFields)
    -> Message_sum_order_by
buildMessage_sum_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_sum_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_sum\_order\_by input object.
-}
type alias Message_sum_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_sum\_order\_by into a value that can be used as an argument.
-}
encodeMessage_sum_order_by : Message_sum_order_by -> Value
encodeMessage_sum_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_updates :
    Message_updatesRequiredFields
    -> (Message_updatesOptionalFields -> Message_updatesOptionalFields)
    -> Message_updates
buildMessage_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Message_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Message_updatesRequiredFields =
    { where_ : Message_bool_exp }


type alias Message_updatesOptionalFields =
    { inc_ : OptionalArgument Message_inc_input
    , set_ : OptionalArgument Message_set_input
    }


{-| Type alias for the `Message_updates` attributes. Note that this type
needs to use the `Message_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Message_updatesRaw =
    { inc_ : OptionalArgument Message_inc_input
    , set_ : OptionalArgument Message_set_input
    , where_ : Message_bool_exp
    }


{-| Type for the Message\_updates input object.
-}
type Message_updates
    = Message_updates Message_updatesRaw


{-| Encode a Message\_updates into a value that can be used as an argument.
-}
encodeMessage_updates : Message_updates -> Value
encodeMessage_updates (Message_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeMessage_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeMessage_set_input |> Encode.optional input____.set_ ), ( "where", encodeMessage_bool_exp input____.where_ |> Just ) ]


buildMessage_var_pop_order_by :
    (Message_var_pop_order_byOptionalFields -> Message_var_pop_order_byOptionalFields)
    -> Message_var_pop_order_by
buildMessage_var_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_var_pop_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_var\_pop\_order\_by input object.
-}
type alias Message_var_pop_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeMessage_var_pop_order_by : Message_var_pop_order_by -> Value
encodeMessage_var_pop_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_var_samp_order_by :
    (Message_var_samp_order_byOptionalFields -> Message_var_samp_order_byOptionalFields)
    -> Message_var_samp_order_by
buildMessage_var_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_var_samp_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_var\_samp\_order\_by input object.
-}
type alias Message_var_samp_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeMessage_var_samp_order_by : Message_var_samp_order_by -> Value
encodeMessage_var_samp_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMessage_variance_order_by :
    (Message_variance_order_byOptionalFields -> Message_variance_order_byOptionalFields)
    -> Message_variance_order_by
buildMessage_variance_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { priority = Absent }
    in
    { priority = optionals____.priority }


type alias Message_variance_order_byOptionalFields =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Message\_variance\_order\_by input object.
-}
type alias Message_variance_order_by =
    { priority : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Message\_variance\_order\_by into a value that can be used as an argument.
-}
encodeMessage_variance_order_by : Message_variance_order_by -> Value
encodeMessage_variance_order_by input____ =
    Encode.maybeObject
        [ ( "priority", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.priority ) ]


buildMinioGetUploadUrlInput :
    MinioGetUploadUrlInputRequiredFields
    -> MinioGetUploadUrlInput
buildMinioGetUploadUrlInput required____ =
    { dummy = required____.dummy }


type alias MinioGetUploadUrlInputRequiredFields =
    { dummy : Bool }


{-| Type for the MinioGetUploadUrlInput input object.
-}
type alias MinioGetUploadUrlInput =
    { dummy : Bool }


{-| Encode a MinioGetUploadUrlInput into a value that can be used as an argument.
-}
encodeMinioGetUploadUrlInput : MinioGetUploadUrlInput -> Value
encodeMinioGetUploadUrlInput input____ =
    Encode.maybeObject
        [ ( "dummy", Encode.bool input____.dummy |> Just ) ]


buildRegisterEmailInput :
    RegisterEmailInputRequiredFields
    -> RegisterEmailInput
buildRegisterEmailInput required____ =
    { email = required____.email }


type alias RegisterEmailInputRequiredFields =
    { email : String }


{-| Type for the RegisterEmailInput input object.
-}
type alias RegisterEmailInput =
    { email : String }


{-| Encode a RegisterEmailInput into a value that can be used as an argument.
-}
encodeRegisterEmailInput : RegisterEmailInput -> Value
encodeRegisterEmailInput input____ =
    Encode.maybeObject
        [ ( "email", Encode.string input____.email |> Just ) ]


buildRole_bool_exp :
    (Role_bool_expOptionalFields -> Role_bool_expOptionalFields)
    -> Role_bool_exp
buildRole_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, value = Absent }
    in
    Role_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, value = optionals____.value }


type alias Role_bool_expOptionalFields =
    { and_ : OptionalArgument (List Role_bool_exp)
    , not_ : OptionalArgument Role_bool_exp
    , or_ : OptionalArgument (List Role_bool_exp)
    , value : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Role_bool_exp` attributes. Note that this type
needs to use the `Role_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_bool_expRaw =
    { and_ : OptionalArgument (List Role_bool_exp)
    , not_ : OptionalArgument Role_bool_exp
    , or_ : OptionalArgument (List Role_bool_exp)
    , value : OptionalArgument String_comparison_exp
    }


{-| Type for the Role\_bool\_exp input object.
-}
type Role_bool_exp
    = Role_bool_exp Role_bool_expRaw


{-| Encode a Role\_bool\_exp into a value that can be used as an argument.
-}
encodeRole_bool_exp : Role_bool_exp -> Value
encodeRole_bool_exp (Role_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeRole_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeRole_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeRole_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "value", encodeString_comparison_exp |> Encode.optional input____.value ) ]


buildRole_enum_comparison_exp :
    (Role_enum_comparison_expOptionalFields -> Role_enum_comparison_expOptionalFields)
    -> Role_enum_comparison_exp
buildRole_enum_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Role_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    , in_ : OptionalArgument (List Hasura.Enum.Role_enum.Role_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    , nin_ : OptionalArgument (List Hasura.Enum.Role_enum.Role_enum)
    }


{-| Type for the Role\_enum\_comparison\_exp input object.
-}
type alias Role_enum_comparison_exp =
    { eq_ : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    , in_ : OptionalArgument (List Hasura.Enum.Role_enum.Role_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    , nin_ : OptionalArgument (List Hasura.Enum.Role_enum.Role_enum)
    }


{-| Encode a Role\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeRole_enum_comparison_exp : Role_enum_comparison_exp -> Value
encodeRole_enum_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.enum Hasura.Enum.Role_enum.toString |> Encode.optional input____.eq_ ), ( "_in", (Encode.enum Hasura.Enum.Role_enum.toString |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_neq", Encode.enum Hasura.Enum.Role_enum.toString |> Encode.optional input____.neq_ ), ( "_nin", (Encode.enum Hasura.Enum.Role_enum.toString |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildRole_insert_input :
    (Role_insert_inputOptionalFields -> Role_insert_inputOptionalFields)
    -> Role_insert_input
buildRole_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { value = Absent }
    in
    { value = optionals____.value }


type alias Role_insert_inputOptionalFields =
    { value : OptionalArgument String }


{-| Type for the Role\_insert\_input input object.
-}
type alias Role_insert_input =
    { value : OptionalArgument String }


{-| Encode a Role\_insert\_input into a value that can be used as an argument.
-}
encodeRole_insert_input : Role_insert_input -> Value
encodeRole_insert_input input____ =
    Encode.maybeObject
        [ ( "value", Encode.string |> Encode.optional input____.value ) ]


buildRole_on_conflict :
    Role_on_conflictRequiredFields
    -> (Role_on_conflictOptionalFields -> Role_on_conflictOptionalFields)
    -> Role_on_conflict
buildRole_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Role_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Role_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Role_constraint.Role_constraint
    , update_columns : List Hasura.Enum.Role_update_column.Role_update_column
    }


type alias Role_on_conflictOptionalFields =
    { where_ : OptionalArgument Role_bool_exp }


{-| Type alias for the `Role_on_conflict` attributes. Note that this type
needs to use the `Role_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_on_conflictRaw =
    { constraint : Hasura.Enum.Role_constraint.Role_constraint
    , update_columns : List Hasura.Enum.Role_update_column.Role_update_column
    , where_ : OptionalArgument Role_bool_exp
    }


{-| Type for the Role\_on\_conflict input object.
-}
type Role_on_conflict
    = Role_on_conflict Role_on_conflictRaw


{-| Encode a Role\_on\_conflict into a value that can be used as an argument.
-}
encodeRole_on_conflict : Role_on_conflict -> Value
encodeRole_on_conflict (Role_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Role_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Role_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeRole_bool_exp |> Encode.optional input____.where_ ) ]


buildRole_order_by :
    (Role_order_byOptionalFields -> Role_order_byOptionalFields)
    -> Role_order_by
buildRole_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { value = Absent }
    in
    { value = optionals____.value }


type alias Role_order_byOptionalFields =
    { value : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Role\_order\_by input object.
-}
type alias Role_order_by =
    { value : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Role\_order\_by into a value that can be used as an argument.
-}
encodeRole_order_by : Role_order_by -> Value
encodeRole_order_by input____ =
    Encode.maybeObject
        [ ( "value", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.value ) ]


buildRole_pk_columns_input :
    Role_pk_columns_inputRequiredFields
    -> Role_pk_columns_input
buildRole_pk_columns_input required____ =
    { value = required____.value }


type alias Role_pk_columns_inputRequiredFields =
    { value : String }


{-| Type for the Role\_pk\_columns\_input input object.
-}
type alias Role_pk_columns_input =
    { value : String }


{-| Encode a Role\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRole_pk_columns_input : Role_pk_columns_input -> Value
encodeRole_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "value", Encode.string input____.value |> Just ) ]


buildRole_set_input :
    (Role_set_inputOptionalFields -> Role_set_inputOptionalFields)
    -> Role_set_input
buildRole_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { value = Absent }
    in
    { value = optionals____.value }


type alias Role_set_inputOptionalFields =
    { value : OptionalArgument String }


{-| Type for the Role\_set\_input input object.
-}
type alias Role_set_input =
    { value : OptionalArgument String }


{-| Encode a Role\_set\_input into a value that can be used as an argument.
-}
encodeRole_set_input : Role_set_input -> Value
encodeRole_set_input input____ =
    Encode.maybeObject
        [ ( "value", Encode.string |> Encode.optional input____.value ) ]


buildRole_stream_cursor_input :
    Role_stream_cursor_inputRequiredFields
    -> (Role_stream_cursor_inputOptionalFields -> Role_stream_cursor_inputOptionalFields)
    -> Role_stream_cursor_input
buildRole_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Role_stream_cursor_inputRequiredFields =
    { initial_value : Role_stream_cursor_value_input }


type alias Role_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Role\_stream\_cursor\_input input object.
-}
type alias Role_stream_cursor_input =
    { initial_value : Role_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Role\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeRole_stream_cursor_input : Role_stream_cursor_input -> Value
encodeRole_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeRole_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildRole_stream_cursor_value_input :
    (Role_stream_cursor_value_inputOptionalFields -> Role_stream_cursor_value_inputOptionalFields)
    -> Role_stream_cursor_value_input
buildRole_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { value = Absent }
    in
    { value = optionals____.value }


type alias Role_stream_cursor_value_inputOptionalFields =
    { value : OptionalArgument String }


{-| Type for the Role\_stream\_cursor\_value\_input input object.
-}
type alias Role_stream_cursor_value_input =
    { value : OptionalArgument String }


{-| Encode a Role\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeRole_stream_cursor_value_input : Role_stream_cursor_value_input -> Value
encodeRole_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "value", Encode.string |> Encode.optional input____.value ) ]


buildRole_updates :
    Role_updatesRequiredFields
    -> (Role_updatesOptionalFields -> Role_updatesOptionalFields)
    -> Role_updates
buildRole_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Role_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Role_updatesRequiredFields =
    { where_ : Role_bool_exp }


type alias Role_updatesOptionalFields =
    { set_ : OptionalArgument Role_set_input }


{-| Type alias for the `Role_updates` attributes. Note that this type
needs to use the `Role_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Role_updatesRaw =
    { set_ : OptionalArgument Role_set_input
    , where_ : Role_bool_exp
    }


{-| Type for the Role\_updates input object.
-}
type Role_updates
    = Role_updates Role_updatesRaw


{-| Encode a Role\_updates into a value that can be used as an argument.
-}
encodeRole_updates : Role_updates -> Value
encodeRole_updates (Role_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeRole_set_input |> Encode.optional input____.set_ ), ( "where", encodeRole_bool_exp input____.where_ |> Just ) ]


buildSaveMediaInput :
    SaveMediaInputRequiredFields
    -> SaveMediaInput
buildSaveMediaInput required____ =
    { mediaId = required____.mediaId }


type alias SaveMediaInputRequiredFields =
    { mediaId : ScalarCodecs.Uuid }


{-| Type for the SaveMediaInput input object.
-}
type alias SaveMediaInput =
    { mediaId : ScalarCodecs.Uuid }


{-| Encode a SaveMediaInput into a value that can be used as an argument.
-}
encodeSaveMediaInput : SaveMediaInput -> Value
encodeSaveMediaInput input____ =
    Encode.maybeObject
        [ ( "mediaId", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.mediaId |> Just ) ]


buildSession_bool_exp :
    (Session_bool_expOptionalFields -> Session_bool_expOptionalFields)
    -> Session_bool_exp
buildSession_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, access_token = Absent, expires_in = Absent, id = Absent, issued_at = Absent, name = Absent, refresh_token = Absent, user_name = Absent }
    in
    Session_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, access_token = optionals____.access_token, expires_in = optionals____.expires_in, id = optionals____.id, issued_at = optionals____.issued_at, name = optionals____.name, refresh_token = optionals____.refresh_token, user_name = optionals____.user_name }


type alias Session_bool_expOptionalFields =
    { and_ : OptionalArgument (List Session_bool_exp)
    , not_ : OptionalArgument Session_bool_exp
    , or_ : OptionalArgument (List Session_bool_exp)
    , access_token : OptionalArgument String_comparison_exp
    , expires_in : OptionalArgument Int_comparison_exp
    , id : OptionalArgument String_comparison_exp
    , issued_at : OptionalArgument Timestamptz_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , refresh_token : OptionalArgument String_comparison_exp
    , user_name : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Session_bool_exp` attributes. Note that this type
needs to use the `Session_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Session_bool_expRaw =
    { and_ : OptionalArgument (List Session_bool_exp)
    , not_ : OptionalArgument Session_bool_exp
    , or_ : OptionalArgument (List Session_bool_exp)
    , access_token : OptionalArgument String_comparison_exp
    , expires_in : OptionalArgument Int_comparison_exp
    , id : OptionalArgument String_comparison_exp
    , issued_at : OptionalArgument Timestamptz_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , refresh_token : OptionalArgument String_comparison_exp
    , user_name : OptionalArgument String_comparison_exp
    }


{-| Type for the Session\_bool\_exp input object.
-}
type Session_bool_exp
    = Session_bool_exp Session_bool_expRaw


{-| Encode a Session\_bool\_exp into a value that can be used as an argument.
-}
encodeSession_bool_exp : Session_bool_exp -> Value
encodeSession_bool_exp (Session_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeSession_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeSession_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeSession_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "access_token", encodeString_comparison_exp |> Encode.optional input____.access_token ), ( "expires_in", encodeInt_comparison_exp |> Encode.optional input____.expires_in ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "issued_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.issued_at ), ( "name", encodeString_comparison_exp |> Encode.optional input____.name ), ( "refresh_token", encodeString_comparison_exp |> Encode.optional input____.refresh_token ), ( "user_name", encodeString_comparison_exp |> Encode.optional input____.user_name ) ]


buildSession_inc_input :
    (Session_inc_inputOptionalFields -> Session_inc_inputOptionalFields)
    -> Session_inc_input
buildSession_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { expires_in = Absent }
    in
    { expires_in = optionals____.expires_in }


type alias Session_inc_inputOptionalFields =
    { expires_in : OptionalArgument Int }


{-| Type for the Session\_inc\_input input object.
-}
type alias Session_inc_input =
    { expires_in : OptionalArgument Int }


{-| Encode a Session\_inc\_input into a value that can be used as an argument.
-}
encodeSession_inc_input : Session_inc_input -> Value
encodeSession_inc_input input____ =
    Encode.maybeObject
        [ ( "expires_in", Encode.int |> Encode.optional input____.expires_in ) ]


buildSession_insert_input :
    (Session_insert_inputOptionalFields -> Session_insert_inputOptionalFields)
    -> Session_insert_input
buildSession_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { access_token = Absent, expires_in = Absent, id = Absent, issued_at = Absent, name = Absent, refresh_token = Absent, user_name = Absent }
    in
    { access_token = optionals____.access_token, expires_in = optionals____.expires_in, id = optionals____.id, issued_at = optionals____.issued_at, name = optionals____.name, refresh_token = optionals____.refresh_token, user_name = optionals____.user_name }


type alias Session_insert_inputOptionalFields =
    { access_token : OptionalArgument String
    , expires_in : OptionalArgument Int
    , id : OptionalArgument String
    , issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , name : OptionalArgument String
    , refresh_token : OptionalArgument String
    , user_name : OptionalArgument String
    }


{-| Type for the Session\_insert\_input input object.
-}
type alias Session_insert_input =
    { access_token : OptionalArgument String
    , expires_in : OptionalArgument Int
    , id : OptionalArgument String
    , issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , name : OptionalArgument String
    , refresh_token : OptionalArgument String
    , user_name : OptionalArgument String
    }


{-| Encode a Session\_insert\_input into a value that can be used as an argument.
-}
encodeSession_insert_input : Session_insert_input -> Value
encodeSession_insert_input input____ =
    Encode.maybeObject
        [ ( "access_token", Encode.string |> Encode.optional input____.access_token ), ( "expires_in", Encode.int |> Encode.optional input____.expires_in ), ( "id", Encode.string |> Encode.optional input____.id ), ( "issued_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.issued_at ), ( "name", Encode.string |> Encode.optional input____.name ), ( "refresh_token", Encode.string |> Encode.optional input____.refresh_token ), ( "user_name", Encode.string |> Encode.optional input____.user_name ) ]


buildSession_on_conflict :
    Session_on_conflictRequiredFields
    -> (Session_on_conflictOptionalFields -> Session_on_conflictOptionalFields)
    -> Session_on_conflict
buildSession_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Session_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Session_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Session_constraint.Session_constraint
    , update_columns : List Hasura.Enum.Session_update_column.Session_update_column
    }


type alias Session_on_conflictOptionalFields =
    { where_ : OptionalArgument Session_bool_exp }


{-| Type alias for the `Session_on_conflict` attributes. Note that this type
needs to use the `Session_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Session_on_conflictRaw =
    { constraint : Hasura.Enum.Session_constraint.Session_constraint
    , update_columns : List Hasura.Enum.Session_update_column.Session_update_column
    , where_ : OptionalArgument Session_bool_exp
    }


{-| Type for the Session\_on\_conflict input object.
-}
type Session_on_conflict
    = Session_on_conflict Session_on_conflictRaw


{-| Encode a Session\_on\_conflict into a value that can be used as an argument.
-}
encodeSession_on_conflict : Session_on_conflict -> Value
encodeSession_on_conflict (Session_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Session_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Session_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeSession_bool_exp |> Encode.optional input____.where_ ) ]


buildSession_order_by :
    (Session_order_byOptionalFields -> Session_order_byOptionalFields)
    -> Session_order_by
buildSession_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { access_token = Absent, expires_in = Absent, id = Absent, issued_at = Absent, name = Absent, refresh_token = Absent, user_name = Absent }
    in
    { access_token = optionals____.access_token, expires_in = optionals____.expires_in, id = optionals____.id, issued_at = optionals____.issued_at, name = optionals____.name, refresh_token = optionals____.refresh_token, user_name = optionals____.user_name }


type alias Session_order_byOptionalFields =
    { access_token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , expires_in : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , issued_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , refresh_token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Session\_order\_by input object.
-}
type alias Session_order_by =
    { access_token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , expires_in : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , issued_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , refresh_token : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Session\_order\_by into a value that can be used as an argument.
-}
encodeSession_order_by : Session_order_by -> Value
encodeSession_order_by input____ =
    Encode.maybeObject
        [ ( "access_token", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.access_token ), ( "expires_in", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.expires_in ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "issued_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.issued_at ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.name ), ( "refresh_token", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.refresh_token ), ( "user_name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_name ) ]


buildSession_pk_columns_input :
    Session_pk_columns_inputRequiredFields
    -> Session_pk_columns_input
buildSession_pk_columns_input required____ =
    { id = required____.id }


type alias Session_pk_columns_inputRequiredFields =
    { id : String }


{-| Type for the Session\_pk\_columns\_input input object.
-}
type alias Session_pk_columns_input =
    { id : String }


{-| Encode a Session\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeSession_pk_columns_input : Session_pk_columns_input -> Value
encodeSession_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string input____.id |> Just ) ]


buildSession_set_input :
    (Session_set_inputOptionalFields -> Session_set_inputOptionalFields)
    -> Session_set_input
buildSession_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { access_token = Absent, expires_in = Absent, id = Absent, issued_at = Absent, name = Absent, refresh_token = Absent, user_name = Absent }
    in
    { access_token = optionals____.access_token, expires_in = optionals____.expires_in, id = optionals____.id, issued_at = optionals____.issued_at, name = optionals____.name, refresh_token = optionals____.refresh_token, user_name = optionals____.user_name }


type alias Session_set_inputOptionalFields =
    { access_token : OptionalArgument String
    , expires_in : OptionalArgument Int
    , id : OptionalArgument String
    , issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , name : OptionalArgument String
    , refresh_token : OptionalArgument String
    , user_name : OptionalArgument String
    }


{-| Type for the Session\_set\_input input object.
-}
type alias Session_set_input =
    { access_token : OptionalArgument String
    , expires_in : OptionalArgument Int
    , id : OptionalArgument String
    , issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , name : OptionalArgument String
    , refresh_token : OptionalArgument String
    , user_name : OptionalArgument String
    }


{-| Encode a Session\_set\_input into a value that can be used as an argument.
-}
encodeSession_set_input : Session_set_input -> Value
encodeSession_set_input input____ =
    Encode.maybeObject
        [ ( "access_token", Encode.string |> Encode.optional input____.access_token ), ( "expires_in", Encode.int |> Encode.optional input____.expires_in ), ( "id", Encode.string |> Encode.optional input____.id ), ( "issued_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.issued_at ), ( "name", Encode.string |> Encode.optional input____.name ), ( "refresh_token", Encode.string |> Encode.optional input____.refresh_token ), ( "user_name", Encode.string |> Encode.optional input____.user_name ) ]


buildSession_stream_cursor_input :
    Session_stream_cursor_inputRequiredFields
    -> (Session_stream_cursor_inputOptionalFields -> Session_stream_cursor_inputOptionalFields)
    -> Session_stream_cursor_input
buildSession_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Session_stream_cursor_inputRequiredFields =
    { initial_value : Session_stream_cursor_value_input }


type alias Session_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Session\_stream\_cursor\_input input object.
-}
type alias Session_stream_cursor_input =
    { initial_value : Session_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Session\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeSession_stream_cursor_input : Session_stream_cursor_input -> Value
encodeSession_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeSession_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildSession_stream_cursor_value_input :
    (Session_stream_cursor_value_inputOptionalFields -> Session_stream_cursor_value_inputOptionalFields)
    -> Session_stream_cursor_value_input
buildSession_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { access_token = Absent, expires_in = Absent, id = Absent, issued_at = Absent, name = Absent, refresh_token = Absent, user_name = Absent }
    in
    { access_token = optionals____.access_token, expires_in = optionals____.expires_in, id = optionals____.id, issued_at = optionals____.issued_at, name = optionals____.name, refresh_token = optionals____.refresh_token, user_name = optionals____.user_name }


type alias Session_stream_cursor_value_inputOptionalFields =
    { access_token : OptionalArgument String
    , expires_in : OptionalArgument Int
    , id : OptionalArgument String
    , issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , name : OptionalArgument String
    , refresh_token : OptionalArgument String
    , user_name : OptionalArgument String
    }


{-| Type for the Session\_stream\_cursor\_value\_input input object.
-}
type alias Session_stream_cursor_value_input =
    { access_token : OptionalArgument String
    , expires_in : OptionalArgument Int
    , id : OptionalArgument String
    , issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , name : OptionalArgument String
    , refresh_token : OptionalArgument String
    , user_name : OptionalArgument String
    }


{-| Encode a Session\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeSession_stream_cursor_value_input : Session_stream_cursor_value_input -> Value
encodeSession_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "access_token", Encode.string |> Encode.optional input____.access_token ), ( "expires_in", Encode.int |> Encode.optional input____.expires_in ), ( "id", Encode.string |> Encode.optional input____.id ), ( "issued_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.issued_at ), ( "name", Encode.string |> Encode.optional input____.name ), ( "refresh_token", Encode.string |> Encode.optional input____.refresh_token ), ( "user_name", Encode.string |> Encode.optional input____.user_name ) ]


buildSession_updates :
    Session_updatesRequiredFields
    -> (Session_updatesOptionalFields -> Session_updatesOptionalFields)
    -> Session_updates
buildSession_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Session_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Session_updatesRequiredFields =
    { where_ : Session_bool_exp }


type alias Session_updatesOptionalFields =
    { inc_ : OptionalArgument Session_inc_input
    , set_ : OptionalArgument Session_set_input
    }


{-| Type alias for the `Session_updates` attributes. Note that this type
needs to use the `Session_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Session_updatesRaw =
    { inc_ : OptionalArgument Session_inc_input
    , set_ : OptionalArgument Session_set_input
    , where_ : Session_bool_exp
    }


{-| Type for the Session\_updates input object.
-}
type Session_updates
    = Session_updates Session_updatesRaw


{-| Encode a Session\_updates into a value that can be used as an argument.
-}
encodeSession_updates : Session_updates -> Value
encodeSession_updates (Session_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeSession_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeSession_set_input |> Encode.optional input____.set_ ), ( "where", encodeSession_bool_exp input____.where_ |> Just ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, iregex_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, niregex_ = Absent, nlike_ = Absent, nregex_ = Absent, nsimilar_ = Absent, regex_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, ilike_ = optionals____.ilike_, in_ = optionals____.in_, iregex_ = optionals____.iregex_, is_null_ = optionals____.is_null_, like_ = optionals____.like_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nilike_ = optionals____.nilike_, nin_ = optionals____.nin_, niregex_ = optionals____.niregex_, nlike_ = optionals____.nlike_, nregex_ = optionals____.nregex_, nsimilar_ = optionals____.nsimilar_, regex_ = optionals____.regex_, similar_ = optionals____.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input____.eq_ ), ( "_gt", Encode.string |> Encode.optional input____.gt_ ), ( "_gte", Encode.string |> Encode.optional input____.gte_ ), ( "_ilike", Encode.string |> Encode.optional input____.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input____.in_ ), ( "_iregex", Encode.string |> Encode.optional input____.iregex_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_like", Encode.string |> Encode.optional input____.like_ ), ( "_lt", Encode.string |> Encode.optional input____.lt_ ), ( "_lte", Encode.string |> Encode.optional input____.lte_ ), ( "_neq", Encode.string |> Encode.optional input____.neq_ ), ( "_nilike", Encode.string |> Encode.optional input____.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input____.nin_ ), ( "_niregex", Encode.string |> Encode.optional input____.niregex_ ), ( "_nlike", Encode.string |> Encode.optional input____.nlike_ ), ( "_nregex", Encode.string |> Encode.optional input____.nregex_ ), ( "_nsimilar", Encode.string |> Encode.optional input____.nsimilar_ ), ( "_regex", Encode.string |> Encode.optional input____.regex_ ), ( "_similar", Encode.string |> Encode.optional input____.similar_ ) ]


buildTag_aggregate_bool_exp :
    (Tag_aggregate_bool_expOptionalFields -> Tag_aggregate_bool_expOptionalFields)
    -> Tag_aggregate_bool_exp
buildTag_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Tag_aggregate_bool_exp { count = optionals____.count }


type alias Tag_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Tag_aggregate_bool_exp_count }


{-| Type alias for the `Tag_aggregate_bool_exp` attributes. Note that this type
needs to use the `Tag_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_aggregate_bool_expRaw =
    { count : OptionalArgument Tag_aggregate_bool_exp_count }


{-| Type for the Tag\_aggregate\_bool\_exp input object.
-}
type Tag_aggregate_bool_exp
    = Tag_aggregate_bool_exp Tag_aggregate_bool_expRaw


{-| Encode a Tag\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeTag_aggregate_bool_exp : Tag_aggregate_bool_exp -> Value
encodeTag_aggregate_bool_exp (Tag_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeTag_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildTag_aggregate_bool_exp_count :
    Tag_aggregate_bool_exp_countRequiredFields
    -> (Tag_aggregate_bool_exp_countOptionalFields -> Tag_aggregate_bool_exp_countOptionalFields)
    -> Tag_aggregate_bool_exp_count
buildTag_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Tag_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Tag_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Tag_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Hasura.Enum.Tag_select_column.Tag_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Tag_bool_exp
    }


{-| Type alias for the `Tag_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Tag_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Hasura.Enum.Tag_select_column.Tag_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Tag_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Tag\_aggregate\_bool\_exp\_count input object.
-}
type Tag_aggregate_bool_exp_count
    = Tag_aggregate_bool_exp_count Tag_aggregate_bool_exp_countRaw


{-| Encode a Tag\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeTag_aggregate_bool_exp_count : Tag_aggregate_bool_exp_count -> Value
encodeTag_aggregate_bool_exp_count (Tag_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Hasura.Enum.Tag_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTag_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildTag_aggregate_order_by :
    (Tag_aggregate_order_byOptionalFields -> Tag_aggregate_order_byOptionalFields)
    -> Tag_aggregate_order_by
buildTag_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Tag_aggregate_order_byOptionalFields =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Tag_max_order_by
    , min : OptionalArgument Tag_min_order_by
    }


{-| Type for the Tag\_aggregate\_order\_by input object.
-}
type alias Tag_aggregate_order_by =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Tag_max_order_by
    , min : OptionalArgument Tag_min_order_by
    }


{-| Encode a Tag\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTag_aggregate_order_by : Tag_aggregate_order_by -> Value
encodeTag_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeTag_max_order_by |> Encode.optional input____.max ), ( "min", encodeTag_min_order_by |> Encode.optional input____.min ) ]


buildTag_arr_rel_insert_input :
    Tag_arr_rel_insert_inputRequiredFields
    -> (Tag_arr_rel_insert_inputOptionalFields -> Tag_arr_rel_insert_inputOptionalFields)
    -> Tag_arr_rel_insert_input
buildTag_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Tag_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Tag_arr_rel_insert_inputRequiredFields =
    { data : List Tag_insert_input }


type alias Tag_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Tag_on_conflict }


{-| Type alias for the `Tag_arr_rel_insert_input` attributes. Note that this type
needs to use the `Tag_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_arr_rel_insert_inputRaw =
    { data : List Tag_insert_input
    , on_conflict : OptionalArgument Tag_on_conflict
    }


{-| Type for the Tag\_arr\_rel\_insert\_input input object.
-}
type Tag_arr_rel_insert_input
    = Tag_arr_rel_insert_input Tag_arr_rel_insert_inputRaw


{-| Encode a Tag\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTag_arr_rel_insert_input : Tag_arr_rel_insert_input -> Value
encodeTag_arr_rel_insert_input (Tag_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeTag_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeTag_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTag_bool_exp :
    (Tag_bool_expOptionalFields -> Tag_bool_expOptionalFields)
    -> Tag_bool_exp
buildTag_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, description = Absent, id = Absent, messages = Absent, messages_aggregate = Absent, name = Absent, user = Absent, user_id = Absent }
    in
    Tag_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, description = optionals____.description, id = optionals____.id, messages = optionals____.messages, messages_aggregate = optionals____.messages_aggregate, name = optionals____.name, user = optionals____.user, user_id = optionals____.user_id }


type alias Tag_bool_expOptionalFields =
    { and_ : OptionalArgument (List Tag_bool_exp)
    , not_ : OptionalArgument Tag_bool_exp
    , or_ : OptionalArgument (List Tag_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , messages : OptionalArgument Message_bool_exp
    , messages_aggregate : OptionalArgument Message_aggregate_bool_exp
    , name : OptionalArgument String_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Tag_bool_exp` attributes. Note that this type
needs to use the `Tag_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_bool_expRaw =
    { and_ : OptionalArgument (List Tag_bool_exp)
    , not_ : OptionalArgument Tag_bool_exp
    , or_ : OptionalArgument (List Tag_bool_exp)
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , messages : OptionalArgument Message_bool_exp
    , messages_aggregate : OptionalArgument Message_aggregate_bool_exp
    , name : OptionalArgument String_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    }


{-| Type for the Tag\_bool\_exp input object.
-}
type Tag_bool_exp
    = Tag_bool_exp Tag_bool_expRaw


{-| Encode a Tag\_bool\_exp into a value that can be used as an argument.
-}
encodeTag_bool_exp : Tag_bool_exp -> Value
encodeTag_bool_exp (Tag_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeTag_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeTag_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeTag_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "description", encodeString_comparison_exp |> Encode.optional input____.description ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "messages", encodeMessage_bool_exp |> Encode.optional input____.messages ), ( "messages_aggregate", encodeMessage_aggregate_bool_exp |> Encode.optional input____.messages_aggregate ), ( "name", encodeString_comparison_exp |> Encode.optional input____.name ), ( "user", encodeUser_bool_exp |> Encode.optional input____.user ), ( "user_id", encodeString_comparison_exp |> Encode.optional input____.user_id ) ]


buildTag_insert_input :
    (Tag_insert_inputOptionalFields -> Tag_insert_inputOptionalFields)
    -> Tag_insert_input
buildTag_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, messages = Absent, name = Absent, user = Absent, user_id = Absent }
    in
    Tag_insert_input { description = optionals____.description, id = optionals____.id, messages = optionals____.messages, name = optionals____.name, user = optionals____.user, user_id = optionals____.user_id }


type alias Tag_insert_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument ScalarCodecs.Uuid
    , messages : OptionalArgument Message_arr_rel_insert_input
    , name : OptionalArgument String
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    }


{-| Type alias for the `Tag_insert_input` attributes. Note that this type
needs to use the `Tag_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_insert_inputRaw =
    { description : OptionalArgument String
    , id : OptionalArgument ScalarCodecs.Uuid
    , messages : OptionalArgument Message_arr_rel_insert_input
    , name : OptionalArgument String
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    }


{-| Type for the Tag\_insert\_input input object.
-}
type Tag_insert_input
    = Tag_insert_input Tag_insert_inputRaw


{-| Encode a Tag\_insert\_input into a value that can be used as an argument.
-}
encodeTag_insert_input : Tag_insert_input -> Value
encodeTag_insert_input (Tag_insert_input input____) =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "messages", encodeMessage_arr_rel_insert_input |> Encode.optional input____.messages ), ( "name", Encode.string |> Encode.optional input____.name ), ( "user", encodeUser_obj_rel_insert_input |> Encode.optional input____.user ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildTag_max_order_by :
    (Tag_max_order_byOptionalFields -> Tag_max_order_byOptionalFields)
    -> Tag_max_order_by
buildTag_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, name = Absent, user_id = Absent }
    in
    { description = optionals____.description, id = optionals____.id, name = optionals____.name, user_id = optionals____.user_id }


type alias Tag_max_order_byOptionalFields =
    { description : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_max\_order\_by input object.
-}
type alias Tag_max_order_by =
    { description : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Tag\_max\_order\_by into a value that can be used as an argument.
-}
encodeTag_max_order_by : Tag_max_order_by -> Value
encodeTag_max_order_by input____ =
    Encode.maybeObject
        [ ( "description", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.name ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTag_min_order_by :
    (Tag_min_order_byOptionalFields -> Tag_min_order_byOptionalFields)
    -> Tag_min_order_by
buildTag_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, name = Absent, user_id = Absent }
    in
    { description = optionals____.description, id = optionals____.id, name = optionals____.name, user_id = optionals____.user_id }


type alias Tag_min_order_byOptionalFields =
    { description : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_min\_order\_by input object.
-}
type alias Tag_min_order_by =
    { description : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Tag\_min\_order\_by into a value that can be used as an argument.
-}
encodeTag_min_order_by : Tag_min_order_by -> Value
encodeTag_min_order_by input____ =
    Encode.maybeObject
        [ ( "description", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.name ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTag_obj_rel_insert_input :
    Tag_obj_rel_insert_inputRequiredFields
    -> (Tag_obj_rel_insert_inputOptionalFields -> Tag_obj_rel_insert_inputOptionalFields)
    -> Tag_obj_rel_insert_input
buildTag_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Tag_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Tag_obj_rel_insert_inputRequiredFields =
    { data : Tag_insert_input }


type alias Tag_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Tag_on_conflict }


{-| Type alias for the `Tag_obj_rel_insert_input` attributes. Note that this type
needs to use the `Tag_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_obj_rel_insert_inputRaw =
    { data : Tag_insert_input
    , on_conflict : OptionalArgument Tag_on_conflict
    }


{-| Type for the Tag\_obj\_rel\_insert\_input input object.
-}
type Tag_obj_rel_insert_input
    = Tag_obj_rel_insert_input Tag_obj_rel_insert_inputRaw


{-| Encode a Tag\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTag_obj_rel_insert_input : Tag_obj_rel_insert_input -> Value
encodeTag_obj_rel_insert_input (Tag_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeTag_insert_input input____.data |> Just ), ( "on_conflict", encodeTag_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTag_on_conflict :
    Tag_on_conflictRequiredFields
    -> (Tag_on_conflictOptionalFields -> Tag_on_conflictOptionalFields)
    -> Tag_on_conflict
buildTag_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Tag_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Tag_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Tag_constraint.Tag_constraint
    , update_columns : List Hasura.Enum.Tag_update_column.Tag_update_column
    }


type alias Tag_on_conflictOptionalFields =
    { where_ : OptionalArgument Tag_bool_exp }


{-| Type alias for the `Tag_on_conflict` attributes. Note that this type
needs to use the `Tag_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_on_conflictRaw =
    { constraint : Hasura.Enum.Tag_constraint.Tag_constraint
    , update_columns : List Hasura.Enum.Tag_update_column.Tag_update_column
    , where_ : OptionalArgument Tag_bool_exp
    }


{-| Type for the Tag\_on\_conflict input object.
-}
type Tag_on_conflict
    = Tag_on_conflict Tag_on_conflictRaw


{-| Encode a Tag\_on\_conflict into a value that can be used as an argument.
-}
encodeTag_on_conflict : Tag_on_conflict -> Value
encodeTag_on_conflict (Tag_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Tag_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Tag_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeTag_bool_exp |> Encode.optional input____.where_ ) ]


buildTag_order_by :
    (Tag_order_byOptionalFields -> Tag_order_byOptionalFields)
    -> Tag_order_by
buildTag_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, messages_aggregate = Absent, name = Absent, user = Absent, user_id = Absent }
    in
    { description = optionals____.description, id = optionals____.id, messages_aggregate = optionals____.messages_aggregate, name = optionals____.name, user = optionals____.user, user_id = optionals____.user_id }


type alias Tag_order_byOptionalFields =
    { description : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , messages_aggregate : OptionalArgument Message_aggregate_order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Tag\_order\_by input object.
-}
type alias Tag_order_by =
    { description : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , messages_aggregate : OptionalArgument Message_aggregate_order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Tag\_order\_by into a value that can be used as an argument.
-}
encodeTag_order_by : Tag_order_by -> Value
encodeTag_order_by input____ =
    Encode.maybeObject
        [ ( "description", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.description ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "messages_aggregate", encodeMessage_aggregate_order_by |> Encode.optional input____.messages_aggregate ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.name ), ( "user", encodeUser_order_by |> Encode.optional input____.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTag_pk_columns_input :
    Tag_pk_columns_inputRequiredFields
    -> Tag_pk_columns_input
buildTag_pk_columns_input required____ =
    { id = required____.id }


type alias Tag_pk_columns_inputRequiredFields =
    { id : ScalarCodecs.Uuid }


{-| Type for the Tag\_pk\_columns\_input input object.
-}
type alias Tag_pk_columns_input =
    { id : ScalarCodecs.Uuid }


{-| Encode a Tag\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTag_pk_columns_input : Tag_pk_columns_input -> Value
encodeTag_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildTag_set_input :
    (Tag_set_inputOptionalFields -> Tag_set_inputOptionalFields)
    -> Tag_set_input
buildTag_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, name = Absent, user_id = Absent }
    in
    { description = optionals____.description, id = optionals____.id, name = optionals____.name, user_id = optionals____.user_id }


type alias Tag_set_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument ScalarCodecs.Uuid
    , name : OptionalArgument String
    , user_id : OptionalArgument String
    }


{-| Type for the Tag\_set\_input input object.
-}
type alias Tag_set_input =
    { description : OptionalArgument String
    , id : OptionalArgument ScalarCodecs.Uuid
    , name : OptionalArgument String
    , user_id : OptionalArgument String
    }


{-| Encode a Tag\_set\_input into a value that can be used as an argument.
-}
encodeTag_set_input : Tag_set_input -> Value
encodeTag_set_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", Encode.string |> Encode.optional input____.name ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildTag_stream_cursor_input :
    Tag_stream_cursor_inputRequiredFields
    -> (Tag_stream_cursor_inputOptionalFields -> Tag_stream_cursor_inputOptionalFields)
    -> Tag_stream_cursor_input
buildTag_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Tag_stream_cursor_inputRequiredFields =
    { initial_value : Tag_stream_cursor_value_input }


type alias Tag_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Tag\_stream\_cursor\_input input object.
-}
type alias Tag_stream_cursor_input =
    { initial_value : Tag_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Tag\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeTag_stream_cursor_input : Tag_stream_cursor_input -> Value
encodeTag_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeTag_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildTag_stream_cursor_value_input :
    (Tag_stream_cursor_value_inputOptionalFields -> Tag_stream_cursor_value_inputOptionalFields)
    -> Tag_stream_cursor_value_input
buildTag_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { description = Absent, id = Absent, name = Absent, user_id = Absent }
    in
    { description = optionals____.description, id = optionals____.id, name = optionals____.name, user_id = optionals____.user_id }


type alias Tag_stream_cursor_value_inputOptionalFields =
    { description : OptionalArgument String
    , id : OptionalArgument ScalarCodecs.Uuid
    , name : OptionalArgument String
    , user_id : OptionalArgument String
    }


{-| Type for the Tag\_stream\_cursor\_value\_input input object.
-}
type alias Tag_stream_cursor_value_input =
    { description : OptionalArgument String
    , id : OptionalArgument ScalarCodecs.Uuid
    , name : OptionalArgument String
    , user_id : OptionalArgument String
    }


{-| Encode a Tag\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeTag_stream_cursor_value_input : Tag_stream_cursor_value_input -> Value
encodeTag_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "description", Encode.string |> Encode.optional input____.description ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "name", Encode.string |> Encode.optional input____.name ), ( "user_id", Encode.string |> Encode.optional input____.user_id ) ]


buildTag_updates :
    Tag_updatesRequiredFields
    -> (Tag_updatesOptionalFields -> Tag_updatesOptionalFields)
    -> Tag_updates
buildTag_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Tag_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Tag_updatesRequiredFields =
    { where_ : Tag_bool_exp }


type alias Tag_updatesOptionalFields =
    { set_ : OptionalArgument Tag_set_input }


{-| Type alias for the `Tag_updates` attributes. Note that this type
needs to use the `Tag_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Tag_updatesRaw =
    { set_ : OptionalArgument Tag_set_input
    , where_ : Tag_bool_exp
    }


{-| Type for the Tag\_updates input object.
-}
type Tag_updates
    = Tag_updates Tag_updatesRaw


{-| Encode a Tag\_updates into a value that can be used as an argument.
-}
encodeTag_updates : Tag_updates -> Value
encodeTag_updates (Tag_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeTag_set_input |> Encode.optional input____.set_ ), ( "where", encodeTag_bool_exp input____.where_ |> Just ) ]


buildTask_fixed_time_aggregate_bool_exp :
    (Task_fixed_time_aggregate_bool_expOptionalFields -> Task_fixed_time_aggregate_bool_expOptionalFields)
    -> Task_fixed_time_aggregate_bool_exp
buildTask_fixed_time_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { bool_and = Absent, bool_or = Absent, count = Absent }
    in
    Task_fixed_time_aggregate_bool_exp { bool_and = optionals____.bool_and, bool_or = optionals____.bool_or, count = optionals____.count }


type alias Task_fixed_time_aggregate_bool_expOptionalFields =
    { bool_and : OptionalArgument Task_fixed_time_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Task_fixed_time_aggregate_bool_exp_bool_or
    , count : OptionalArgument Task_fixed_time_aggregate_bool_exp_count
    }


{-| Type alias for the `Task_fixed_time_aggregate_bool_exp` attributes. Note that this type
needs to use the `Task_fixed_time_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_aggregate_bool_expRaw =
    { bool_and : OptionalArgument Task_fixed_time_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Task_fixed_time_aggregate_bool_exp_bool_or
    , count : OptionalArgument Task_fixed_time_aggregate_bool_exp_count
    }


{-| Type for the Task\_fixed\_time\_aggregate\_bool\_exp input object.
-}
type Task_fixed_time_aggregate_bool_exp
    = Task_fixed_time_aggregate_bool_exp Task_fixed_time_aggregate_bool_expRaw


{-| Encode a Task\_fixed\_time\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeTask_fixed_time_aggregate_bool_exp : Task_fixed_time_aggregate_bool_exp -> Value
encodeTask_fixed_time_aggregate_bool_exp (Task_fixed_time_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "bool_and", encodeTask_fixed_time_aggregate_bool_exp_bool_and |> Encode.optional input____.bool_and ), ( "bool_or", encodeTask_fixed_time_aggregate_bool_exp_bool_or |> Encode.optional input____.bool_or ), ( "count", encodeTask_fixed_time_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildTask_fixed_time_aggregate_bool_exp_bool_and :
    Task_fixed_time_aggregate_bool_exp_bool_andRequiredFields
    -> (Task_fixed_time_aggregate_bool_exp_bool_andOptionalFields -> Task_fixed_time_aggregate_bool_exp_bool_andOptionalFields)
    -> Task_fixed_time_aggregate_bool_exp_bool_and
buildTask_fixed_time_aggregate_bool_exp_bool_and required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Task_fixed_time_aggregate_bool_exp_bool_and { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Task_fixed_time_aggregate_bool_exp_bool_andRequiredFields =
    { arguments : Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Task_fixed_time_aggregate_bool_exp_bool_andOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_fixed_time_bool_exp
    }


{-| Type alias for the `Task_fixed_time_aggregate_bool_exp_bool_and` attributes. Note that this type
needs to use the `Task_fixed_time_aggregate_bool_exp_bool_and` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_aggregate_bool_exp_bool_andRaw =
    { arguments : Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_fixed_time_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Task\_fixed\_time\_aggregate\_bool\_exp\_bool\_and input object.
-}
type Task_fixed_time_aggregate_bool_exp_bool_and
    = Task_fixed_time_aggregate_bool_exp_bool_and Task_fixed_time_aggregate_bool_exp_bool_andRaw


{-| Encode a Task\_fixed\_time\_aggregate\_bool\_exp\_bool\_and into a value that can be used as an argument.
-}
encodeTask_fixed_time_aggregate_bool_exp_bool_and : Task_fixed_time_aggregate_bool_exp_bool_and -> Value
encodeTask_fixed_time_aggregate_bool_exp_bool_and (Task_fixed_time_aggregate_bool_exp_bool_and input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_and_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTask_fixed_time_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildTask_fixed_time_aggregate_bool_exp_bool_or :
    Task_fixed_time_aggregate_bool_exp_bool_orRequiredFields
    -> (Task_fixed_time_aggregate_bool_exp_bool_orOptionalFields -> Task_fixed_time_aggregate_bool_exp_bool_orOptionalFields)
    -> Task_fixed_time_aggregate_bool_exp_bool_or
buildTask_fixed_time_aggregate_bool_exp_bool_or required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Task_fixed_time_aggregate_bool_exp_bool_or { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Task_fixed_time_aggregate_bool_exp_bool_orRequiredFields =
    { arguments : Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Task_fixed_time_aggregate_bool_exp_bool_orOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_fixed_time_bool_exp
    }


{-| Type alias for the `Task_fixed_time_aggregate_bool_exp_bool_or` attributes. Note that this type
needs to use the `Task_fixed_time_aggregate_bool_exp_bool_or` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_aggregate_bool_exp_bool_orRaw =
    { arguments : Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_fixed_time_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Task\_fixed\_time\_aggregate\_bool\_exp\_bool\_or input object.
-}
type Task_fixed_time_aggregate_bool_exp_bool_or
    = Task_fixed_time_aggregate_bool_exp_bool_or Task_fixed_time_aggregate_bool_exp_bool_orRaw


{-| Encode a Task\_fixed\_time\_aggregate\_bool\_exp\_bool\_or into a value that can be used as an argument.
-}
encodeTask_fixed_time_aggregate_bool_exp_bool_or : Task_fixed_time_aggregate_bool_exp_bool_or -> Value
encodeTask_fixed_time_aggregate_bool_exp_bool_or (Task_fixed_time_aggregate_bool_exp_bool_or input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum Hasura.Enum.Task_fixed_time_select_column_task_fixed_time_aggregate_bool_exp_bool_or_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTask_fixed_time_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildTask_fixed_time_aggregate_bool_exp_count :
    Task_fixed_time_aggregate_bool_exp_countRequiredFields
    -> (Task_fixed_time_aggregate_bool_exp_countOptionalFields -> Task_fixed_time_aggregate_bool_exp_countOptionalFields)
    -> Task_fixed_time_aggregate_bool_exp_count
buildTask_fixed_time_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Task_fixed_time_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Task_fixed_time_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Task_fixed_time_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Hasura.Enum.Task_fixed_time_select_column.Task_fixed_time_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_fixed_time_bool_exp
    }


{-| Type alias for the `Task_fixed_time_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Task_fixed_time_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Hasura.Enum.Task_fixed_time_select_column.Task_fixed_time_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_fixed_time_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Task\_fixed\_time\_aggregate\_bool\_exp\_count input object.
-}
type Task_fixed_time_aggregate_bool_exp_count
    = Task_fixed_time_aggregate_bool_exp_count Task_fixed_time_aggregate_bool_exp_countRaw


{-| Encode a Task\_fixed\_time\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeTask_fixed_time_aggregate_bool_exp_count : Task_fixed_time_aggregate_bool_exp_count -> Value
encodeTask_fixed_time_aggregate_bool_exp_count (Task_fixed_time_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Hasura.Enum.Task_fixed_time_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTask_fixed_time_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildTask_fixed_time_aggregate_order_by :
    (Task_fixed_time_aggregate_order_byOptionalFields -> Task_fixed_time_aggregate_order_byOptionalFields)
    -> Task_fixed_time_aggregate_order_by
buildTask_fixed_time_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Task_fixed_time_aggregate_order_byOptionalFields =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Task_fixed_time_max_order_by
    , min : OptionalArgument Task_fixed_time_min_order_by
    }


{-| Type for the Task\_fixed\_time\_aggregate\_order\_by input object.
-}
type alias Task_fixed_time_aggregate_order_by =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Task_fixed_time_max_order_by
    , min : OptionalArgument Task_fixed_time_min_order_by
    }


{-| Encode a Task\_fixed\_time\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTask_fixed_time_aggregate_order_by : Task_fixed_time_aggregate_order_by -> Value
encodeTask_fixed_time_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeTask_fixed_time_max_order_by |> Encode.optional input____.max ), ( "min", encodeTask_fixed_time_min_order_by |> Encode.optional input____.min ) ]


buildTask_fixed_time_arr_rel_insert_input :
    Task_fixed_time_arr_rel_insert_inputRequiredFields
    -> (Task_fixed_time_arr_rel_insert_inputOptionalFields -> Task_fixed_time_arr_rel_insert_inputOptionalFields)
    -> Task_fixed_time_arr_rel_insert_input
buildTask_fixed_time_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Task_fixed_time_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Task_fixed_time_arr_rel_insert_inputRequiredFields =
    { data : List Task_fixed_time_insert_input }


type alias Task_fixed_time_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Task_fixed_time_on_conflict }


{-| Type alias for the `Task_fixed_time_arr_rel_insert_input` attributes. Note that this type
needs to use the `Task_fixed_time_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_arr_rel_insert_inputRaw =
    { data : List Task_fixed_time_insert_input
    , on_conflict : OptionalArgument Task_fixed_time_on_conflict
    }


{-| Type for the Task\_fixed\_time\_arr\_rel\_insert\_input input object.
-}
type Task_fixed_time_arr_rel_insert_input
    = Task_fixed_time_arr_rel_insert_input Task_fixed_time_arr_rel_insert_inputRaw


{-| Encode a Task\_fixed\_time\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTask_fixed_time_arr_rel_insert_input : Task_fixed_time_arr_rel_insert_input -> Value
encodeTask_fixed_time_arr_rel_insert_input (Task_fixed_time_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeTask_fixed_time_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeTask_fixed_time_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTask_fixed_time_bool_exp :
    (Task_fixed_time_bool_expOptionalFields -> Task_fixed_time_bool_expOptionalFields)
    -> Task_fixed_time_bool_exp
buildTask_fixed_time_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, enabled = Absent, fri = Absent, id = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, tag = Absent, tag_id = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, user = Absent, user_id = Absent, wed = Absent }
    in
    Task_fixed_time_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, tag = optionals____.tag, tag_id = optionals____.tag_id, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, user = optionals____.user, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_fixed_time_bool_expOptionalFields =
    { and_ : OptionalArgument (List Task_fixed_time_bool_exp)
    , not_ : OptionalArgument Task_fixed_time_bool_exp
    , or_ : OptionalArgument (List Task_fixed_time_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , enabled : OptionalArgument Boolean_comparison_exp
    , fri : OptionalArgument Boolean_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , mon : OptionalArgument Boolean_comparison_exp
    , random : OptionalArgument Boolean_comparison_exp
    , sat : OptionalArgument Boolean_comparison_exp
    , sun : OptionalArgument Boolean_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    , thu : OptionalArgument Boolean_comparison_exp
    , tue : OptionalArgument Boolean_comparison_exp
    , tweet_at : OptionalArgument Time_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    , wed : OptionalArgument Boolean_comparison_exp
    }


{-| Type alias for the `Task_fixed_time_bool_exp` attributes. Note that this type
needs to use the `Task_fixed_time_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_bool_expRaw =
    { and_ : OptionalArgument (List Task_fixed_time_bool_exp)
    , not_ : OptionalArgument Task_fixed_time_bool_exp
    , or_ : OptionalArgument (List Task_fixed_time_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , enabled : OptionalArgument Boolean_comparison_exp
    , fri : OptionalArgument Boolean_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , mon : OptionalArgument Boolean_comparison_exp
    , random : OptionalArgument Boolean_comparison_exp
    , sat : OptionalArgument Boolean_comparison_exp
    , sun : OptionalArgument Boolean_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_id : OptionalArgument Uuid_comparison_exp
    , thu : OptionalArgument Boolean_comparison_exp
    , tue : OptionalArgument Boolean_comparison_exp
    , tweet_at : OptionalArgument Time_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    , wed : OptionalArgument Boolean_comparison_exp
    }


{-| Type for the Task\_fixed\_time\_bool\_exp input object.
-}
type Task_fixed_time_bool_exp
    = Task_fixed_time_bool_exp Task_fixed_time_bool_expRaw


{-| Encode a Task\_fixed\_time\_bool\_exp into a value that can be used as an argument.
-}
encodeTask_fixed_time_bool_exp : Task_fixed_time_bool_exp -> Value
encodeTask_fixed_time_bool_exp (Task_fixed_time_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeTask_fixed_time_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeTask_fixed_time_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeTask_fixed_time_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "enabled", encodeBoolean_comparison_exp |> Encode.optional input____.enabled ), ( "fri", encodeBoolean_comparison_exp |> Encode.optional input____.fri ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "mon", encodeBoolean_comparison_exp |> Encode.optional input____.mon ), ( "random", encodeBoolean_comparison_exp |> Encode.optional input____.random ), ( "sat", encodeBoolean_comparison_exp |> Encode.optional input____.sat ), ( "sun", encodeBoolean_comparison_exp |> Encode.optional input____.sun ), ( "tag", encodeTag_bool_exp |> Encode.optional input____.tag ), ( "tag_id", encodeUuid_comparison_exp |> Encode.optional input____.tag_id ), ( "thu", encodeBoolean_comparison_exp |> Encode.optional input____.thu ), ( "tue", encodeBoolean_comparison_exp |> Encode.optional input____.tue ), ( "tweet_at", encodeTime_comparison_exp |> Encode.optional input____.tweet_at ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ), ( "user", encodeUser_bool_exp |> Encode.optional input____.user ), ( "user_id", encodeString_comparison_exp |> Encode.optional input____.user_id ), ( "wed", encodeBoolean_comparison_exp |> Encode.optional input____.wed ) ]


buildTask_fixed_time_insert_input :
    (Task_fixed_time_insert_inputOptionalFields -> Task_fixed_time_insert_inputOptionalFields)
    -> Task_fixed_time_insert_input
buildTask_fixed_time_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, tag = Absent, tag_id = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, user = Absent, user_id = Absent, wed = Absent }
    in
    Task_fixed_time_insert_input { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, tag = optionals____.tag, tag_id = optionals____.tag_id, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, user = optionals____.user, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_fixed_time_insert_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , tag : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type alias for the `Task_fixed_time_insert_input` attributes. Note that this type
needs to use the `Task_fixed_time_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_insert_inputRaw =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , tag : OptionalArgument Tag_obj_rel_insert_input
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type for the Task\_fixed\_time\_insert\_input input object.
-}
type Task_fixed_time_insert_input
    = Task_fixed_time_insert_input Task_fixed_time_insert_inputRaw


{-| Encode a Task\_fixed\_time\_insert\_input into a value that can be used as an argument.
-}
encodeTask_fixed_time_insert_input : Task_fixed_time_insert_input -> Value
encodeTask_fixed_time_insert_input (Task_fixed_time_insert_input input____) =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "enabled", Encode.bool |> Encode.optional input____.enabled ), ( "fri", Encode.bool |> Encode.optional input____.fri ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "mon", Encode.bool |> Encode.optional input____.mon ), ( "random", Encode.bool |> Encode.optional input____.random ), ( "sat", Encode.bool |> Encode.optional input____.sat ), ( "sun", Encode.bool |> Encode.optional input____.sun ), ( "tag", encodeTag_obj_rel_insert_input |> Encode.optional input____.tag ), ( "tag_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.tag_id ), ( "thu", Encode.bool |> Encode.optional input____.thu ), ( "tue", Encode.bool |> Encode.optional input____.tue ), ( "tweet_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.tweet_at ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "user", encodeUser_obj_rel_insert_input |> Encode.optional input____.user ), ( "user_id", Encode.string |> Encode.optional input____.user_id ), ( "wed", Encode.bool |> Encode.optional input____.wed ) ]


buildTask_fixed_time_max_order_by :
    (Task_fixed_time_max_order_byOptionalFields -> Task_fixed_time_max_order_byOptionalFields)
    -> Task_fixed_time_max_order_by
buildTask_fixed_time_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, tag_id = Absent, updated_at = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, tag_id = optionals____.tag_id, updated_at = optionals____.updated_at, user_id = optionals____.user_id }


type alias Task_fixed_time_max_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Task\_fixed\_time\_max\_order\_by input object.
-}
type alias Task_fixed_time_max_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Task\_fixed\_time\_max\_order\_by into a value that can be used as an argument.
-}
encodeTask_fixed_time_max_order_by : Task_fixed_time_max_order_by -> Value
encodeTask_fixed_time_max_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "tag_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tag_id ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTask_fixed_time_min_order_by :
    (Task_fixed_time_min_order_byOptionalFields -> Task_fixed_time_min_order_byOptionalFields)
    -> Task_fixed_time_min_order_by
buildTask_fixed_time_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, tag_id = Absent, updated_at = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, tag_id = optionals____.tag_id, updated_at = optionals____.updated_at, user_id = optionals____.user_id }


type alias Task_fixed_time_min_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Task\_fixed\_time\_min\_order\_by input object.
-}
type alias Task_fixed_time_min_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Task\_fixed\_time\_min\_order\_by into a value that can be used as an argument.
-}
encodeTask_fixed_time_min_order_by : Task_fixed_time_min_order_by -> Value
encodeTask_fixed_time_min_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "tag_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tag_id ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTask_fixed_time_on_conflict :
    Task_fixed_time_on_conflictRequiredFields
    -> (Task_fixed_time_on_conflictOptionalFields -> Task_fixed_time_on_conflictOptionalFields)
    -> Task_fixed_time_on_conflict
buildTask_fixed_time_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Task_fixed_time_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Task_fixed_time_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Task_fixed_time_constraint.Task_fixed_time_constraint
    , update_columns : List Hasura.Enum.Task_fixed_time_update_column.Task_fixed_time_update_column
    }


type alias Task_fixed_time_on_conflictOptionalFields =
    { where_ : OptionalArgument Task_fixed_time_bool_exp }


{-| Type alias for the `Task_fixed_time_on_conflict` attributes. Note that this type
needs to use the `Task_fixed_time_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_on_conflictRaw =
    { constraint : Hasura.Enum.Task_fixed_time_constraint.Task_fixed_time_constraint
    , update_columns : List Hasura.Enum.Task_fixed_time_update_column.Task_fixed_time_update_column
    , where_ : OptionalArgument Task_fixed_time_bool_exp
    }


{-| Type for the Task\_fixed\_time\_on\_conflict input object.
-}
type Task_fixed_time_on_conflict
    = Task_fixed_time_on_conflict Task_fixed_time_on_conflictRaw


{-| Encode a Task\_fixed\_time\_on\_conflict into a value that can be used as an argument.
-}
encodeTask_fixed_time_on_conflict : Task_fixed_time_on_conflict -> Value
encodeTask_fixed_time_on_conflict (Task_fixed_time_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Task_fixed_time_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Task_fixed_time_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeTask_fixed_time_bool_exp |> Encode.optional input____.where_ ) ]


buildTask_fixed_time_order_by :
    (Task_fixed_time_order_byOptionalFields -> Task_fixed_time_order_byOptionalFields)
    -> Task_fixed_time_order_by
buildTask_fixed_time_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, tag = Absent, tag_id = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, user = Absent, user_id = Absent, wed = Absent }
    in
    { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, tag = optionals____.tag, tag_id = optionals____.tag_id, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, user = optionals____.user, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_fixed_time_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , enabled : OptionalArgument Hasura.Enum.Order_by.Order_by
    , fri : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , mon : OptionalArgument Hasura.Enum.Order_by.Order_by
    , random : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sat : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sun : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thu : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tue : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tweet_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , wed : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Task\_fixed\_time\_order\_by input object.
-}
type alias Task_fixed_time_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , enabled : OptionalArgument Hasura.Enum.Order_by.Order_by
    , fri : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , mon : OptionalArgument Hasura.Enum.Order_by.Order_by
    , random : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sat : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sun : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag : OptionalArgument Tag_order_by
    , tag_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thu : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tue : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tweet_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , wed : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Task\_fixed\_time\_order\_by into a value that can be used as an argument.
-}
encodeTask_fixed_time_order_by : Task_fixed_time_order_by -> Value
encodeTask_fixed_time_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "enabled", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.enabled ), ( "fri", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.fri ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "mon", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.mon ), ( "random", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.random ), ( "sat", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.sat ), ( "sun", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.sun ), ( "tag", encodeTag_order_by |> Encode.optional input____.tag ), ( "tag_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tag_id ), ( "thu", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.thu ), ( "tue", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tue ), ( "tweet_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tweet_at ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "user", encodeUser_order_by |> Encode.optional input____.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ), ( "wed", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.wed ) ]


buildTask_fixed_time_pk_columns_input :
    Task_fixed_time_pk_columns_inputRequiredFields
    -> Task_fixed_time_pk_columns_input
buildTask_fixed_time_pk_columns_input required____ =
    { id = required____.id }


type alias Task_fixed_time_pk_columns_inputRequiredFields =
    { id : ScalarCodecs.Uuid }


{-| Type for the Task\_fixed\_time\_pk\_columns\_input input object.
-}
type alias Task_fixed_time_pk_columns_input =
    { id : ScalarCodecs.Uuid }


{-| Encode a Task\_fixed\_time\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTask_fixed_time_pk_columns_input : Task_fixed_time_pk_columns_input -> Value
encodeTask_fixed_time_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildTask_fixed_time_set_input :
    (Task_fixed_time_set_inputOptionalFields -> Task_fixed_time_set_inputOptionalFields)
    -> Task_fixed_time_set_input
buildTask_fixed_time_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, tag_id = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, user_id = Absent, wed = Absent }
    in
    { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, tag_id = optionals____.tag_id, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_fixed_time_set_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type for the Task\_fixed\_time\_set\_input input object.
-}
type alias Task_fixed_time_set_input =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Encode a Task\_fixed\_time\_set\_input into a value that can be used as an argument.
-}
encodeTask_fixed_time_set_input : Task_fixed_time_set_input -> Value
encodeTask_fixed_time_set_input input____ =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "enabled", Encode.bool |> Encode.optional input____.enabled ), ( "fri", Encode.bool |> Encode.optional input____.fri ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "mon", Encode.bool |> Encode.optional input____.mon ), ( "random", Encode.bool |> Encode.optional input____.random ), ( "sat", Encode.bool |> Encode.optional input____.sat ), ( "sun", Encode.bool |> Encode.optional input____.sun ), ( "tag_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.tag_id ), ( "thu", Encode.bool |> Encode.optional input____.thu ), ( "tue", Encode.bool |> Encode.optional input____.tue ), ( "tweet_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.tweet_at ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ), ( "wed", Encode.bool |> Encode.optional input____.wed ) ]


buildTask_fixed_time_stream_cursor_input :
    Task_fixed_time_stream_cursor_inputRequiredFields
    -> (Task_fixed_time_stream_cursor_inputOptionalFields -> Task_fixed_time_stream_cursor_inputOptionalFields)
    -> Task_fixed_time_stream_cursor_input
buildTask_fixed_time_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Task_fixed_time_stream_cursor_inputRequiredFields =
    { initial_value : Task_fixed_time_stream_cursor_value_input }


type alias Task_fixed_time_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Task\_fixed\_time\_stream\_cursor\_input input object.
-}
type alias Task_fixed_time_stream_cursor_input =
    { initial_value : Task_fixed_time_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Task\_fixed\_time\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeTask_fixed_time_stream_cursor_input : Task_fixed_time_stream_cursor_input -> Value
encodeTask_fixed_time_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeTask_fixed_time_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildTask_fixed_time_stream_cursor_value_input :
    (Task_fixed_time_stream_cursor_value_inputOptionalFields -> Task_fixed_time_stream_cursor_value_inputOptionalFields)
    -> Task_fixed_time_stream_cursor_value_input
buildTask_fixed_time_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, tag_id = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, user_id = Absent, wed = Absent }
    in
    { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, tag_id = optionals____.tag_id, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_fixed_time_stream_cursor_value_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type for the Task\_fixed\_time\_stream\_cursor\_value\_input input object.
-}
type alias Task_fixed_time_stream_cursor_value_input =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , tag_id : OptionalArgument ScalarCodecs.Uuid
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Encode a Task\_fixed\_time\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeTask_fixed_time_stream_cursor_value_input : Task_fixed_time_stream_cursor_value_input -> Value
encodeTask_fixed_time_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "enabled", Encode.bool |> Encode.optional input____.enabled ), ( "fri", Encode.bool |> Encode.optional input____.fri ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "mon", Encode.bool |> Encode.optional input____.mon ), ( "random", Encode.bool |> Encode.optional input____.random ), ( "sat", Encode.bool |> Encode.optional input____.sat ), ( "sun", Encode.bool |> Encode.optional input____.sun ), ( "tag_id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.tag_id ), ( "thu", Encode.bool |> Encode.optional input____.thu ), ( "tue", Encode.bool |> Encode.optional input____.tue ), ( "tweet_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.tweet_at ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "user_id", Encode.string |> Encode.optional input____.user_id ), ( "wed", Encode.bool |> Encode.optional input____.wed ) ]


buildTask_fixed_time_updates :
    Task_fixed_time_updatesRequiredFields
    -> (Task_fixed_time_updatesOptionalFields -> Task_fixed_time_updatesOptionalFields)
    -> Task_fixed_time_updates
buildTask_fixed_time_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Task_fixed_time_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Task_fixed_time_updatesRequiredFields =
    { where_ : Task_fixed_time_bool_exp }


type alias Task_fixed_time_updatesOptionalFields =
    { set_ : OptionalArgument Task_fixed_time_set_input }


{-| Type alias for the `Task_fixed_time_updates` attributes. Note that this type
needs to use the `Task_fixed_time_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_fixed_time_updatesRaw =
    { set_ : OptionalArgument Task_fixed_time_set_input
    , where_ : Task_fixed_time_bool_exp
    }


{-| Type for the Task\_fixed\_time\_updates input object.
-}
type Task_fixed_time_updates
    = Task_fixed_time_updates Task_fixed_time_updatesRaw


{-| Encode a Task\_fixed\_time\_updates into a value that can be used as an argument.
-}
encodeTask_fixed_time_updates : Task_fixed_time_updates -> Value
encodeTask_fixed_time_updates (Task_fixed_time_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeTask_fixed_time_set_input |> Encode.optional input____.set_ ), ( "where", encodeTask_fixed_time_bool_exp input____.where_ |> Just ) ]


buildTask_rss_aggregate_bool_exp :
    (Task_rss_aggregate_bool_expOptionalFields -> Task_rss_aggregate_bool_expOptionalFields)
    -> Task_rss_aggregate_bool_exp
buildTask_rss_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { bool_and = Absent, bool_or = Absent, count = Absent }
    in
    Task_rss_aggregate_bool_exp { bool_and = optionals____.bool_and, bool_or = optionals____.bool_or, count = optionals____.count }


type alias Task_rss_aggregate_bool_expOptionalFields =
    { bool_and : OptionalArgument Task_rss_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Task_rss_aggregate_bool_exp_bool_or
    , count : OptionalArgument Task_rss_aggregate_bool_exp_count
    }


{-| Type alias for the `Task_rss_aggregate_bool_exp` attributes. Note that this type
needs to use the `Task_rss_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_aggregate_bool_expRaw =
    { bool_and : OptionalArgument Task_rss_aggregate_bool_exp_bool_and
    , bool_or : OptionalArgument Task_rss_aggregate_bool_exp_bool_or
    , count : OptionalArgument Task_rss_aggregate_bool_exp_count
    }


{-| Type for the Task\_rss\_aggregate\_bool\_exp input object.
-}
type Task_rss_aggregate_bool_exp
    = Task_rss_aggregate_bool_exp Task_rss_aggregate_bool_expRaw


{-| Encode a Task\_rss\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeTask_rss_aggregate_bool_exp : Task_rss_aggregate_bool_exp -> Value
encodeTask_rss_aggregate_bool_exp (Task_rss_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "bool_and", encodeTask_rss_aggregate_bool_exp_bool_and |> Encode.optional input____.bool_and ), ( "bool_or", encodeTask_rss_aggregate_bool_exp_bool_or |> Encode.optional input____.bool_or ), ( "count", encodeTask_rss_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildTask_rss_aggregate_bool_exp_bool_and :
    Task_rss_aggregate_bool_exp_bool_andRequiredFields
    -> (Task_rss_aggregate_bool_exp_bool_andOptionalFields -> Task_rss_aggregate_bool_exp_bool_andOptionalFields)
    -> Task_rss_aggregate_bool_exp_bool_and
buildTask_rss_aggregate_bool_exp_bool_and required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Task_rss_aggregate_bool_exp_bool_and { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Task_rss_aggregate_bool_exp_bool_andRequiredFields =
    { arguments : Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Task_rss_aggregate_bool_exp_bool_andOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_rss_bool_exp
    }


{-| Type alias for the `Task_rss_aggregate_bool_exp_bool_and` attributes. Note that this type
needs to use the `Task_rss_aggregate_bool_exp_bool_and` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_aggregate_bool_exp_bool_andRaw =
    { arguments : Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_rss_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Task\_rss\_aggregate\_bool\_exp\_bool\_and input object.
-}
type Task_rss_aggregate_bool_exp_bool_and
    = Task_rss_aggregate_bool_exp_bool_and Task_rss_aggregate_bool_exp_bool_andRaw


{-| Encode a Task\_rss\_aggregate\_bool\_exp\_bool\_and into a value that can be used as an argument.
-}
encodeTask_rss_aggregate_bool_exp_bool_and : Task_rss_aggregate_bool_exp_bool_and -> Value
encodeTask_rss_aggregate_bool_exp_bool_and (Task_rss_aggregate_bool_exp_bool_and input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_and_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTask_rss_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildTask_rss_aggregate_bool_exp_bool_or :
    Task_rss_aggregate_bool_exp_bool_orRequiredFields
    -> (Task_rss_aggregate_bool_exp_bool_orOptionalFields -> Task_rss_aggregate_bool_exp_bool_orOptionalFields)
    -> Task_rss_aggregate_bool_exp_bool_or
buildTask_rss_aggregate_bool_exp_bool_or required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { distinct = Absent, filter = Absent }
    in
    Task_rss_aggregate_bool_exp_bool_or { arguments = required____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Task_rss_aggregate_bool_exp_bool_orRequiredFields =
    { arguments : Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns
    , predicate : Boolean_comparison_exp
    }


type alias Task_rss_aggregate_bool_exp_bool_orOptionalFields =
    { distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_rss_bool_exp
    }


{-| Type alias for the `Task_rss_aggregate_bool_exp_bool_or` attributes. Note that this type
needs to use the `Task_rss_aggregate_bool_exp_bool_or` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_aggregate_bool_exp_bool_orRaw =
    { arguments : Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_rss_bool_exp
    , predicate : Boolean_comparison_exp
    }


{-| Type for the Task\_rss\_aggregate\_bool\_exp\_bool\_or input object.
-}
type Task_rss_aggregate_bool_exp_bool_or
    = Task_rss_aggregate_bool_exp_bool_or Task_rss_aggregate_bool_exp_bool_orRaw


{-| Encode a Task\_rss\_aggregate\_bool\_exp\_bool\_or into a value that can be used as an argument.
-}
encodeTask_rss_aggregate_bool_exp_bool_or : Task_rss_aggregate_bool_exp_bool_or -> Value
encodeTask_rss_aggregate_bool_exp_bool_or (Task_rss_aggregate_bool_exp_bool_or input____) =
    Encode.maybeObject
        [ ( "arguments", Encode.enum Hasura.Enum.Task_rss_select_column_task_rss_aggregate_bool_exp_bool_or_arguments_columns.toString input____.arguments |> Just ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTask_rss_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeBoolean_comparison_exp input____.predicate |> Just ) ]


buildTask_rss_aggregate_bool_exp_count :
    Task_rss_aggregate_bool_exp_countRequiredFields
    -> (Task_rss_aggregate_bool_exp_countOptionalFields -> Task_rss_aggregate_bool_exp_countOptionalFields)
    -> Task_rss_aggregate_bool_exp_count
buildTask_rss_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Task_rss_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Task_rss_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Task_rss_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Hasura.Enum.Task_rss_select_column.Task_rss_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_rss_bool_exp
    }


{-| Type alias for the `Task_rss_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Task_rss_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Hasura.Enum.Task_rss_select_column.Task_rss_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Task_rss_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Task\_rss\_aggregate\_bool\_exp\_count input object.
-}
type Task_rss_aggregate_bool_exp_count
    = Task_rss_aggregate_bool_exp_count Task_rss_aggregate_bool_exp_countRaw


{-| Encode a Task\_rss\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeTask_rss_aggregate_bool_exp_count : Task_rss_aggregate_bool_exp_count -> Value
encodeTask_rss_aggregate_bool_exp_count (Task_rss_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Hasura.Enum.Task_rss_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTask_rss_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildTask_rss_aggregate_order_by :
    (Task_rss_aggregate_order_byOptionalFields -> Task_rss_aggregate_order_byOptionalFields)
    -> Task_rss_aggregate_order_by
buildTask_rss_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals____.count, max = optionals____.max, min = optionals____.min }


type alias Task_rss_aggregate_order_byOptionalFields =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Task_rss_max_order_by
    , min : OptionalArgument Task_rss_min_order_by
    }


{-| Type for the Task\_rss\_aggregate\_order\_by input object.
-}
type alias Task_rss_aggregate_order_by =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Task_rss_max_order_by
    , min : OptionalArgument Task_rss_min_order_by
    }


{-| Encode a Task\_rss\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTask_rss_aggregate_order_by : Task_rss_aggregate_order_by -> Value
encodeTask_rss_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeTask_rss_max_order_by |> Encode.optional input____.max ), ( "min", encodeTask_rss_min_order_by |> Encode.optional input____.min ) ]


buildTask_rss_arr_rel_insert_input :
    Task_rss_arr_rel_insert_inputRequiredFields
    -> (Task_rss_arr_rel_insert_inputOptionalFields -> Task_rss_arr_rel_insert_inputOptionalFields)
    -> Task_rss_arr_rel_insert_input
buildTask_rss_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Task_rss_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Task_rss_arr_rel_insert_inputRequiredFields =
    { data : List Task_rss_insert_input }


type alias Task_rss_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Task_rss_on_conflict }


{-| Type alias for the `Task_rss_arr_rel_insert_input` attributes. Note that this type
needs to use the `Task_rss_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_arr_rel_insert_inputRaw =
    { data : List Task_rss_insert_input
    , on_conflict : OptionalArgument Task_rss_on_conflict
    }


{-| Type for the Task\_rss\_arr\_rel\_insert\_input input object.
-}
type Task_rss_arr_rel_insert_input
    = Task_rss_arr_rel_insert_input Task_rss_arr_rel_insert_inputRaw


{-| Encode a Task\_rss\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTask_rss_arr_rel_insert_input : Task_rss_arr_rel_insert_input -> Value
encodeTask_rss_arr_rel_insert_input (Task_rss_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeTask_rss_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeTask_rss_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTask_rss_bool_exp :
    (Task_rss_bool_expOptionalFields -> Task_rss_bool_expOptionalFields)
    -> Task_rss_bool_exp
buildTask_rss_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, enabled = Absent, fri = Absent, id = Absent, last_pub_date = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, template = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, url = Absent, user = Absent, user_id = Absent, wed = Absent }
    in
    Task_rss_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, last_pub_date = optionals____.last_pub_date, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, template = optionals____.template, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, url = optionals____.url, user = optionals____.user, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_rss_bool_expOptionalFields =
    { and_ : OptionalArgument (List Task_rss_bool_exp)
    , not_ : OptionalArgument Task_rss_bool_exp
    , or_ : OptionalArgument (List Task_rss_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , enabled : OptionalArgument Boolean_comparison_exp
    , fri : OptionalArgument Boolean_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , last_pub_date : OptionalArgument Timestamptz_comparison_exp
    , mon : OptionalArgument Boolean_comparison_exp
    , random : OptionalArgument Boolean_comparison_exp
    , sat : OptionalArgument Boolean_comparison_exp
    , sun : OptionalArgument Boolean_comparison_exp
    , template : OptionalArgument String_comparison_exp
    , thu : OptionalArgument Boolean_comparison_exp
    , tue : OptionalArgument Boolean_comparison_exp
    , tweet_at : OptionalArgument Time_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , url : OptionalArgument String_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    , wed : OptionalArgument Boolean_comparison_exp
    }


{-| Type alias for the `Task_rss_bool_exp` attributes. Note that this type
needs to use the `Task_rss_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_bool_expRaw =
    { and_ : OptionalArgument (List Task_rss_bool_exp)
    , not_ : OptionalArgument Task_rss_bool_exp
    , or_ : OptionalArgument (List Task_rss_bool_exp)
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , enabled : OptionalArgument Boolean_comparison_exp
    , fri : OptionalArgument Boolean_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , last_pub_date : OptionalArgument Timestamptz_comparison_exp
    , mon : OptionalArgument Boolean_comparison_exp
    , random : OptionalArgument Boolean_comparison_exp
    , sat : OptionalArgument Boolean_comparison_exp
    , sun : OptionalArgument Boolean_comparison_exp
    , template : OptionalArgument String_comparison_exp
    , thu : OptionalArgument Boolean_comparison_exp
    , tue : OptionalArgument Boolean_comparison_exp
    , tweet_at : OptionalArgument Time_comparison_exp
    , updated_at : OptionalArgument Timestamptz_comparison_exp
    , url : OptionalArgument String_comparison_exp
    , user : OptionalArgument User_bool_exp
    , user_id : OptionalArgument String_comparison_exp
    , wed : OptionalArgument Boolean_comparison_exp
    }


{-| Type for the Task\_rss\_bool\_exp input object.
-}
type Task_rss_bool_exp
    = Task_rss_bool_exp Task_rss_bool_expRaw


{-| Encode a Task\_rss\_bool\_exp into a value that can be used as an argument.
-}
encodeTask_rss_bool_exp : Task_rss_bool_exp -> Value
encodeTask_rss_bool_exp (Task_rss_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeTask_rss_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeTask_rss_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeTask_rss_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.created_at ), ( "enabled", encodeBoolean_comparison_exp |> Encode.optional input____.enabled ), ( "fri", encodeBoolean_comparison_exp |> Encode.optional input____.fri ), ( "id", encodeUuid_comparison_exp |> Encode.optional input____.id ), ( "last_pub_date", encodeTimestamptz_comparison_exp |> Encode.optional input____.last_pub_date ), ( "mon", encodeBoolean_comparison_exp |> Encode.optional input____.mon ), ( "random", encodeBoolean_comparison_exp |> Encode.optional input____.random ), ( "sat", encodeBoolean_comparison_exp |> Encode.optional input____.sat ), ( "sun", encodeBoolean_comparison_exp |> Encode.optional input____.sun ), ( "template", encodeString_comparison_exp |> Encode.optional input____.template ), ( "thu", encodeBoolean_comparison_exp |> Encode.optional input____.thu ), ( "tue", encodeBoolean_comparison_exp |> Encode.optional input____.tue ), ( "tweet_at", encodeTime_comparison_exp |> Encode.optional input____.tweet_at ), ( "updated_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.updated_at ), ( "url", encodeString_comparison_exp |> Encode.optional input____.url ), ( "user", encodeUser_bool_exp |> Encode.optional input____.user ), ( "user_id", encodeString_comparison_exp |> Encode.optional input____.user_id ), ( "wed", encodeBoolean_comparison_exp |> Encode.optional input____.wed ) ]


buildTask_rss_insert_input :
    (Task_rss_insert_inputOptionalFields -> Task_rss_insert_inputOptionalFields)
    -> Task_rss_insert_input
buildTask_rss_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, last_pub_date = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, template = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, url = Absent, user = Absent, user_id = Absent, wed = Absent }
    in
    Task_rss_insert_input { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, last_pub_date = optionals____.last_pub_date, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, template = optionals____.template, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, url = optionals____.url, user = optionals____.user, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_rss_insert_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , last_pub_date : OptionalArgument ScalarCodecs.Timestamptz
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , template : OptionalArgument String
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , url : OptionalArgument String
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type alias for the `Task_rss_insert_input` attributes. Note that this type
needs to use the `Task_rss_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_insert_inputRaw =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , last_pub_date : OptionalArgument ScalarCodecs.Timestamptz
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , template : OptionalArgument String
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , url : OptionalArgument String
    , user : OptionalArgument User_obj_rel_insert_input
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type for the Task\_rss\_insert\_input input object.
-}
type Task_rss_insert_input
    = Task_rss_insert_input Task_rss_insert_inputRaw


{-| Encode a Task\_rss\_insert\_input into a value that can be used as an argument.
-}
encodeTask_rss_insert_input : Task_rss_insert_input -> Value
encodeTask_rss_insert_input (Task_rss_insert_input input____) =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "enabled", Encode.bool |> Encode.optional input____.enabled ), ( "fri", Encode.bool |> Encode.optional input____.fri ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "last_pub_date", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_pub_date ), ( "mon", Encode.bool |> Encode.optional input____.mon ), ( "random", Encode.bool |> Encode.optional input____.random ), ( "sat", Encode.bool |> Encode.optional input____.sat ), ( "sun", Encode.bool |> Encode.optional input____.sun ), ( "template", Encode.string |> Encode.optional input____.template ), ( "thu", Encode.bool |> Encode.optional input____.thu ), ( "tue", Encode.bool |> Encode.optional input____.tue ), ( "tweet_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.tweet_at ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "url", Encode.string |> Encode.optional input____.url ), ( "user", encodeUser_obj_rel_insert_input |> Encode.optional input____.user ), ( "user_id", Encode.string |> Encode.optional input____.user_id ), ( "wed", Encode.bool |> Encode.optional input____.wed ) ]


buildTask_rss_max_order_by :
    (Task_rss_max_order_byOptionalFields -> Task_rss_max_order_byOptionalFields)
    -> Task_rss_max_order_by
buildTask_rss_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, last_pub_date = Absent, template = Absent, updated_at = Absent, url = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, last_pub_date = optionals____.last_pub_date, template = optionals____.template, updated_at = optionals____.updated_at, url = optionals____.url, user_id = optionals____.user_id }


type alias Task_rss_max_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_pub_date : OptionalArgument Hasura.Enum.Order_by.Order_by
    , template : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , url : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Task\_rss\_max\_order\_by input object.
-}
type alias Task_rss_max_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_pub_date : OptionalArgument Hasura.Enum.Order_by.Order_by
    , template : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , url : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Task\_rss\_max\_order\_by into a value that can be used as an argument.
-}
encodeTask_rss_max_order_by : Task_rss_max_order_by -> Value
encodeTask_rss_max_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "last_pub_date", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.last_pub_date ), ( "template", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.template ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "url", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.url ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTask_rss_min_order_by :
    (Task_rss_min_order_byOptionalFields -> Task_rss_min_order_byOptionalFields)
    -> Task_rss_min_order_by
buildTask_rss_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, id = Absent, last_pub_date = Absent, template = Absent, updated_at = Absent, url = Absent, user_id = Absent }
    in
    { created_at = optionals____.created_at, id = optionals____.id, last_pub_date = optionals____.last_pub_date, template = optionals____.template, updated_at = optionals____.updated_at, url = optionals____.url, user_id = optionals____.user_id }


type alias Task_rss_min_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_pub_date : OptionalArgument Hasura.Enum.Order_by.Order_by
    , template : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , url : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Task\_rss\_min\_order\_by input object.
-}
type alias Task_rss_min_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_pub_date : OptionalArgument Hasura.Enum.Order_by.Order_by
    , template : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , url : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Task\_rss\_min\_order\_by into a value that can be used as an argument.
-}
encodeTask_rss_min_order_by : Task_rss_min_order_by -> Value
encodeTask_rss_min_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "last_pub_date", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.last_pub_date ), ( "template", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.template ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "url", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.url ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ) ]


buildTask_rss_on_conflict :
    Task_rss_on_conflictRequiredFields
    -> (Task_rss_on_conflictOptionalFields -> Task_rss_on_conflictOptionalFields)
    -> Task_rss_on_conflict
buildTask_rss_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Task_rss_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Task_rss_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Task_rss_constraint.Task_rss_constraint
    , update_columns : List Hasura.Enum.Task_rss_update_column.Task_rss_update_column
    }


type alias Task_rss_on_conflictOptionalFields =
    { where_ : OptionalArgument Task_rss_bool_exp }


{-| Type alias for the `Task_rss_on_conflict` attributes. Note that this type
needs to use the `Task_rss_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_on_conflictRaw =
    { constraint : Hasura.Enum.Task_rss_constraint.Task_rss_constraint
    , update_columns : List Hasura.Enum.Task_rss_update_column.Task_rss_update_column
    , where_ : OptionalArgument Task_rss_bool_exp
    }


{-| Type for the Task\_rss\_on\_conflict input object.
-}
type Task_rss_on_conflict
    = Task_rss_on_conflict Task_rss_on_conflictRaw


{-| Encode a Task\_rss\_on\_conflict into a value that can be used as an argument.
-}
encodeTask_rss_on_conflict : Task_rss_on_conflict -> Value
encodeTask_rss_on_conflict (Task_rss_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Task_rss_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Task_rss_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeTask_rss_bool_exp |> Encode.optional input____.where_ ) ]


buildTask_rss_order_by :
    (Task_rss_order_byOptionalFields -> Task_rss_order_byOptionalFields)
    -> Task_rss_order_by
buildTask_rss_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, last_pub_date = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, template = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, url = Absent, user = Absent, user_id = Absent, wed = Absent }
    in
    { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, last_pub_date = optionals____.last_pub_date, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, template = optionals____.template, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, url = optionals____.url, user = optionals____.user, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_rss_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , enabled : OptionalArgument Hasura.Enum.Order_by.Order_by
    , fri : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_pub_date : OptionalArgument Hasura.Enum.Order_by.Order_by
    , mon : OptionalArgument Hasura.Enum.Order_by.Order_by
    , random : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sat : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sun : OptionalArgument Hasura.Enum.Order_by.Order_by
    , template : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thu : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tue : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tweet_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , url : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , wed : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Task\_rss\_order\_by input object.
-}
type alias Task_rss_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , enabled : OptionalArgument Hasura.Enum.Order_by.Order_by
    , fri : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_pub_date : OptionalArgument Hasura.Enum.Order_by.Order_by
    , mon : OptionalArgument Hasura.Enum.Order_by.Order_by
    , random : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sat : OptionalArgument Hasura.Enum.Order_by.Order_by
    , sun : OptionalArgument Hasura.Enum.Order_by.Order_by
    , template : OptionalArgument Hasura.Enum.Order_by.Order_by
    , thu : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tue : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tweet_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , updated_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , url : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument User_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , wed : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Task\_rss\_order\_by into a value that can be used as an argument.
-}
encodeTask_rss_order_by : Task_rss_order_by -> Value
encodeTask_rss_order_by input____ =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.created_at ), ( "enabled", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.enabled ), ( "fri", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.fri ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "last_pub_date", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.last_pub_date ), ( "mon", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.mon ), ( "random", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.random ), ( "sat", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.sat ), ( "sun", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.sun ), ( "template", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.template ), ( "thu", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.thu ), ( "tue", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tue ), ( "tweet_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.tweet_at ), ( "updated_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.updated_at ), ( "url", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.url ), ( "user", encodeUser_order_by |> Encode.optional input____.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.user_id ), ( "wed", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.wed ) ]


buildTask_rss_pk_columns_input :
    Task_rss_pk_columns_inputRequiredFields
    -> Task_rss_pk_columns_input
buildTask_rss_pk_columns_input required____ =
    { id = required____.id }


type alias Task_rss_pk_columns_inputRequiredFields =
    { id : ScalarCodecs.Uuid }


{-| Type for the Task\_rss\_pk\_columns\_input input object.
-}
type alias Task_rss_pk_columns_input =
    { id : ScalarCodecs.Uuid }


{-| Encode a Task\_rss\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTask_rss_pk_columns_input : Task_rss_pk_columns_input -> Value
encodeTask_rss_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) input____.id |> Just ) ]


buildTask_rss_set_input :
    (Task_rss_set_inputOptionalFields -> Task_rss_set_inputOptionalFields)
    -> Task_rss_set_input
buildTask_rss_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, last_pub_date = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, template = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, url = Absent, user_id = Absent, wed = Absent }
    in
    { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, last_pub_date = optionals____.last_pub_date, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, template = optionals____.template, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, url = optionals____.url, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_rss_set_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , last_pub_date : OptionalArgument ScalarCodecs.Timestamptz
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , template : OptionalArgument String
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , url : OptionalArgument String
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type for the Task\_rss\_set\_input input object.
-}
type alias Task_rss_set_input =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , last_pub_date : OptionalArgument ScalarCodecs.Timestamptz
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , template : OptionalArgument String
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , url : OptionalArgument String
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Encode a Task\_rss\_set\_input into a value that can be used as an argument.
-}
encodeTask_rss_set_input : Task_rss_set_input -> Value
encodeTask_rss_set_input input____ =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "enabled", Encode.bool |> Encode.optional input____.enabled ), ( "fri", Encode.bool |> Encode.optional input____.fri ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "last_pub_date", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_pub_date ), ( "mon", Encode.bool |> Encode.optional input____.mon ), ( "random", Encode.bool |> Encode.optional input____.random ), ( "sat", Encode.bool |> Encode.optional input____.sat ), ( "sun", Encode.bool |> Encode.optional input____.sun ), ( "template", Encode.string |> Encode.optional input____.template ), ( "thu", Encode.bool |> Encode.optional input____.thu ), ( "tue", Encode.bool |> Encode.optional input____.tue ), ( "tweet_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.tweet_at ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "url", Encode.string |> Encode.optional input____.url ), ( "user_id", Encode.string |> Encode.optional input____.user_id ), ( "wed", Encode.bool |> Encode.optional input____.wed ) ]


buildTask_rss_stream_cursor_input :
    Task_rss_stream_cursor_inputRequiredFields
    -> (Task_rss_stream_cursor_inputOptionalFields -> Task_rss_stream_cursor_inputOptionalFields)
    -> Task_rss_stream_cursor_input
buildTask_rss_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Task_rss_stream_cursor_inputRequiredFields =
    { initial_value : Task_rss_stream_cursor_value_input }


type alias Task_rss_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Task\_rss\_stream\_cursor\_input input object.
-}
type alias Task_rss_stream_cursor_input =
    { initial_value : Task_rss_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Task\_rss\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeTask_rss_stream_cursor_input : Task_rss_stream_cursor_input -> Value
encodeTask_rss_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeTask_rss_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildTask_rss_stream_cursor_value_input :
    (Task_rss_stream_cursor_value_inputOptionalFields -> Task_rss_stream_cursor_value_inputOptionalFields)
    -> Task_rss_stream_cursor_value_input
buildTask_rss_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { created_at = Absent, enabled = Absent, fri = Absent, id = Absent, last_pub_date = Absent, mon = Absent, random = Absent, sat = Absent, sun = Absent, template = Absent, thu = Absent, tue = Absent, tweet_at = Absent, updated_at = Absent, url = Absent, user_id = Absent, wed = Absent }
    in
    { created_at = optionals____.created_at, enabled = optionals____.enabled, fri = optionals____.fri, id = optionals____.id, last_pub_date = optionals____.last_pub_date, mon = optionals____.mon, random = optionals____.random, sat = optionals____.sat, sun = optionals____.sun, template = optionals____.template, thu = optionals____.thu, tue = optionals____.tue, tweet_at = optionals____.tweet_at, updated_at = optionals____.updated_at, url = optionals____.url, user_id = optionals____.user_id, wed = optionals____.wed }


type alias Task_rss_stream_cursor_value_inputOptionalFields =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , last_pub_date : OptionalArgument ScalarCodecs.Timestamptz
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , template : OptionalArgument String
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , url : OptionalArgument String
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Type for the Task\_rss\_stream\_cursor\_value\_input input object.
-}
type alias Task_rss_stream_cursor_value_input =
    { created_at : OptionalArgument ScalarCodecs.Timestamptz
    , enabled : OptionalArgument Bool
    , fri : OptionalArgument Bool
    , id : OptionalArgument ScalarCodecs.Uuid
    , last_pub_date : OptionalArgument ScalarCodecs.Timestamptz
    , mon : OptionalArgument Bool
    , random : OptionalArgument Bool
    , sat : OptionalArgument Bool
    , sun : OptionalArgument Bool
    , template : OptionalArgument String
    , thu : OptionalArgument Bool
    , tue : OptionalArgument Bool
    , tweet_at : OptionalArgument ScalarCodecs.Time
    , updated_at : OptionalArgument ScalarCodecs.Timestamptz
    , url : OptionalArgument String
    , user_id : OptionalArgument String
    , wed : OptionalArgument Bool
    }


{-| Encode a Task\_rss\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeTask_rss_stream_cursor_value_input : Task_rss_stream_cursor_value_input -> Value
encodeTask_rss_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "created_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.created_at ), ( "enabled", Encode.bool |> Encode.optional input____.enabled ), ( "fri", Encode.bool |> Encode.optional input____.fri ), ( "id", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.id ), ( "last_pub_date", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_pub_date ), ( "mon", Encode.bool |> Encode.optional input____.mon ), ( "random", Encode.bool |> Encode.optional input____.random ), ( "sat", Encode.bool |> Encode.optional input____.sat ), ( "sun", Encode.bool |> Encode.optional input____.sun ), ( "template", Encode.string |> Encode.optional input____.template ), ( "thu", Encode.bool |> Encode.optional input____.thu ), ( "tue", Encode.bool |> Encode.optional input____.tue ), ( "tweet_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.tweet_at ), ( "updated_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.updated_at ), ( "url", Encode.string |> Encode.optional input____.url ), ( "user_id", Encode.string |> Encode.optional input____.user_id ), ( "wed", Encode.bool |> Encode.optional input____.wed ) ]


buildTask_rss_updates :
    Task_rss_updatesRequiredFields
    -> (Task_rss_updatesOptionalFields -> Task_rss_updatesOptionalFields)
    -> Task_rss_updates
buildTask_rss_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Task_rss_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Task_rss_updatesRequiredFields =
    { where_ : Task_rss_bool_exp }


type alias Task_rss_updatesOptionalFields =
    { set_ : OptionalArgument Task_rss_set_input }


{-| Type alias for the `Task_rss_updates` attributes. Note that this type
needs to use the `Task_rss_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Task_rss_updatesRaw =
    { set_ : OptionalArgument Task_rss_set_input
    , where_ : Task_rss_bool_exp
    }


{-| Type for the Task\_rss\_updates input object.
-}
type Task_rss_updates
    = Task_rss_updates Task_rss_updatesRaw


{-| Encode a Task\_rss\_updates into a value that can be used as an argument.
-}
encodeTask_rss_updates : Task_rss_updates -> Value
encodeTask_rss_updates (Task_rss_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeTask_rss_set_input |> Encode.optional input____.set_ ), ( "where", encodeTask_rss_bool_exp input____.where_ |> Just ) ]


buildTime_comparison_exp :
    (Time_comparison_expOptionalFields -> Time_comparison_expOptionalFields)
    -> Time_comparison_exp
buildTime_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Time_comparison_expOptionalFields =
    { eq_ : OptionalArgument ScalarCodecs.Time
    , gt_ : OptionalArgument ScalarCodecs.Time
    , gte_ : OptionalArgument ScalarCodecs.Time
    , in_ : OptionalArgument (List ScalarCodecs.Time)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Time
    , lte_ : OptionalArgument ScalarCodecs.Time
    , neq_ : OptionalArgument ScalarCodecs.Time
    , nin_ : OptionalArgument (List ScalarCodecs.Time)
    }


{-| Type for the Time\_comparison\_exp input object.
-}
type alias Time_comparison_exp =
    { eq_ : OptionalArgument ScalarCodecs.Time
    , gt_ : OptionalArgument ScalarCodecs.Time
    , gte_ : OptionalArgument ScalarCodecs.Time
    , in_ : OptionalArgument (List ScalarCodecs.Time)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Time
    , lte_ : OptionalArgument ScalarCodecs.Time
    , neq_ : OptionalArgument ScalarCodecs.Time
    , nin_ : OptionalArgument (List ScalarCodecs.Time)
    }


{-| Encode a Time\_comparison\_exp into a value that can be used as an argument.
-}
encodeTime_comparison_exp : Time_comparison_exp -> Value
encodeTime_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.eq_ ), ( "_gt", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.gt_ ), ( "_gte", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.gte_ ), ( "_in", ((ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.lt_ ), ( "_lte", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.lte_ ), ( "_neq", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.optional input____.neq_ ), ( "_nin", ((ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTime) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildTimestamptz_comparison_exp :
    (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields)
    -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.eq_ ), ( "_gt", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.gt_ ), ( "_gte", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.gte_ ), ( "_in", ((ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lt_ ), ( "_lte", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.lte_ ), ( "_neq", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.neq_ ), ( "_nin", ((ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildUser_bool_exp :
    (User_bool_expOptionalFields -> User_bool_expOptionalFields)
    -> User_bool_exp
buildUser_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, active = Absent, email = Absent, email_confirm_code = Absent, email_confirm_code_issued_at = Absent, email_confirmed = Absent, email_confirmed_at = Absent, id = Absent, last_seen = Absent, medias = Absent, medias_aggregate = Absent, messages = Absent, messages_aggregate = Absent, registered_at = Absent, role = Absent, tag = Absent, tag_aggregate = Absent, tasks_fixed_time = Absent, tasks_fixed_time_aggregate = Absent, tasks_rss = Absent, tasks_rss_aggregate = Absent }
    in
    User_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, active = optionals____.active, email = optionals____.email, email_confirm_code = optionals____.email_confirm_code, email_confirm_code_issued_at = optionals____.email_confirm_code_issued_at, email_confirmed = optionals____.email_confirmed, email_confirmed_at = optionals____.email_confirmed_at, id = optionals____.id, last_seen = optionals____.last_seen, medias = optionals____.medias, medias_aggregate = optionals____.medias_aggregate, messages = optionals____.messages, messages_aggregate = optionals____.messages_aggregate, registered_at = optionals____.registered_at, role = optionals____.role, tag = optionals____.tag, tag_aggregate = optionals____.tag_aggregate, tasks_fixed_time = optionals____.tasks_fixed_time, tasks_fixed_time_aggregate = optionals____.tasks_fixed_time_aggregate, tasks_rss = optionals____.tasks_rss, tasks_rss_aggregate = optionals____.tasks_rss_aggregate }


type alias User_bool_expOptionalFields =
    { and_ : OptionalArgument (List User_bool_exp)
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List User_bool_exp)
    , active : OptionalArgument Boolean_comparison_exp
    , email : OptionalArgument String_comparison_exp
    , email_confirm_code : OptionalArgument String_comparison_exp
    , email_confirm_code_issued_at : OptionalArgument Timestamptz_comparison_exp
    , email_confirmed : OptionalArgument Boolean_comparison_exp
    , email_confirmed_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument String_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , medias : OptionalArgument Media_bool_exp
    , medias_aggregate : OptionalArgument Media_aggregate_bool_exp
    , messages : OptionalArgument Message_bool_exp
    , messages_aggregate : OptionalArgument Message_aggregate_bool_exp
    , registered_at : OptionalArgument Timestamptz_comparison_exp
    , role : OptionalArgument Role_enum_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_aggregate : OptionalArgument Tag_aggregate_bool_exp
    , tasks_fixed_time : OptionalArgument Task_fixed_time_bool_exp
    , tasks_fixed_time_aggregate : OptionalArgument Task_fixed_time_aggregate_bool_exp
    , tasks_rss : OptionalArgument Task_rss_bool_exp
    , tasks_rss_aggregate : OptionalArgument Task_rss_aggregate_bool_exp
    }


{-| Type alias for the `User_bool_exp` attributes. Note that this type
needs to use the `User_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_bool_expRaw =
    { and_ : OptionalArgument (List User_bool_exp)
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List User_bool_exp)
    , active : OptionalArgument Boolean_comparison_exp
    , email : OptionalArgument String_comparison_exp
    , email_confirm_code : OptionalArgument String_comparison_exp
    , email_confirm_code_issued_at : OptionalArgument Timestamptz_comparison_exp
    , email_confirmed : OptionalArgument Boolean_comparison_exp
    , email_confirmed_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument String_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , medias : OptionalArgument Media_bool_exp
    , medias_aggregate : OptionalArgument Media_aggregate_bool_exp
    , messages : OptionalArgument Message_bool_exp
    , messages_aggregate : OptionalArgument Message_aggregate_bool_exp
    , registered_at : OptionalArgument Timestamptz_comparison_exp
    , role : OptionalArgument Role_enum_comparison_exp
    , tag : OptionalArgument Tag_bool_exp
    , tag_aggregate : OptionalArgument Tag_aggregate_bool_exp
    , tasks_fixed_time : OptionalArgument Task_fixed_time_bool_exp
    , tasks_fixed_time_aggregate : OptionalArgument Task_fixed_time_aggregate_bool_exp
    , tasks_rss : OptionalArgument Task_rss_bool_exp
    , tasks_rss_aggregate : OptionalArgument Task_rss_aggregate_bool_exp
    }


{-| Type for the User\_bool\_exp input object.
-}
type User_bool_exp
    = User_bool_exp User_bool_expRaw


{-| Encode a User\_bool\_exp into a value that can be used as an argument.
-}
encodeUser_bool_exp : User_bool_exp -> Value
encodeUser_bool_exp (User_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeUser_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeUser_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeUser_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "active", encodeBoolean_comparison_exp |> Encode.optional input____.active ), ( "email", encodeString_comparison_exp |> Encode.optional input____.email ), ( "email_confirm_code", encodeString_comparison_exp |> Encode.optional input____.email_confirm_code ), ( "email_confirm_code_issued_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.email_confirm_code_issued_at ), ( "email_confirmed", encodeBoolean_comparison_exp |> Encode.optional input____.email_confirmed ), ( "email_confirmed_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.email_confirmed_at ), ( "id", encodeString_comparison_exp |> Encode.optional input____.id ), ( "last_seen", encodeTimestamptz_comparison_exp |> Encode.optional input____.last_seen ), ( "medias", encodeMedia_bool_exp |> Encode.optional input____.medias ), ( "medias_aggregate", encodeMedia_aggregate_bool_exp |> Encode.optional input____.medias_aggregate ), ( "messages", encodeMessage_bool_exp |> Encode.optional input____.messages ), ( "messages_aggregate", encodeMessage_aggregate_bool_exp |> Encode.optional input____.messages_aggregate ), ( "registered_at", encodeTimestamptz_comparison_exp |> Encode.optional input____.registered_at ), ( "role", encodeRole_enum_comparison_exp |> Encode.optional input____.role ), ( "tag", encodeTag_bool_exp |> Encode.optional input____.tag ), ( "tag_aggregate", encodeTag_aggregate_bool_exp |> Encode.optional input____.tag_aggregate ), ( "tasks_fixed_time", encodeTask_fixed_time_bool_exp |> Encode.optional input____.tasks_fixed_time ), ( "tasks_fixed_time_aggregate", encodeTask_fixed_time_aggregate_bool_exp |> Encode.optional input____.tasks_fixed_time_aggregate ), ( "tasks_rss", encodeTask_rss_bool_exp |> Encode.optional input____.tasks_rss ), ( "tasks_rss_aggregate", encodeTask_rss_aggregate_bool_exp |> Encode.optional input____.tasks_rss_aggregate ) ]


buildUser_insert_input :
    (User_insert_inputOptionalFields -> User_insert_inputOptionalFields)
    -> User_insert_input
buildUser_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { active = Absent, email = Absent, email_confirm_code = Absent, email_confirm_code_issued_at = Absent, email_confirmed = Absent, email_confirmed_at = Absent, id = Absent, last_seen = Absent, medias = Absent, messages = Absent, registered_at = Absent, role = Absent, tag = Absent, tasks_fixed_time = Absent, tasks_rss = Absent }
    in
    User_insert_input { active = optionals____.active, email = optionals____.email, email_confirm_code = optionals____.email_confirm_code, email_confirm_code_issued_at = optionals____.email_confirm_code_issued_at, email_confirmed = optionals____.email_confirmed, email_confirmed_at = optionals____.email_confirmed_at, id = optionals____.id, last_seen = optionals____.last_seen, medias = optionals____.medias, messages = optionals____.messages, registered_at = optionals____.registered_at, role = optionals____.role, tag = optionals____.tag, tasks_fixed_time = optionals____.tasks_fixed_time, tasks_rss = optionals____.tasks_rss }


type alias User_insert_inputOptionalFields =
    { active : OptionalArgument Bool
    , email : OptionalArgument String
    , email_confirm_code : OptionalArgument String
    , email_confirm_code_issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , email_confirmed : OptionalArgument Bool
    , email_confirmed_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument String
    , last_seen : OptionalArgument ScalarCodecs.Timestamptz
    , medias : OptionalArgument Media_arr_rel_insert_input
    , messages : OptionalArgument Message_arr_rel_insert_input
    , registered_at : OptionalArgument ScalarCodecs.Timestamptz
    , role : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    , tag : OptionalArgument Tag_arr_rel_insert_input
    , tasks_fixed_time : OptionalArgument Task_fixed_time_arr_rel_insert_input
    , tasks_rss : OptionalArgument Task_rss_arr_rel_insert_input
    }


{-| Type alias for the `User_insert_input` attributes. Note that this type
needs to use the `User_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_insert_inputRaw =
    { active : OptionalArgument Bool
    , email : OptionalArgument String
    , email_confirm_code : OptionalArgument String
    , email_confirm_code_issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , email_confirmed : OptionalArgument Bool
    , email_confirmed_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument String
    , last_seen : OptionalArgument ScalarCodecs.Timestamptz
    , medias : OptionalArgument Media_arr_rel_insert_input
    , messages : OptionalArgument Message_arr_rel_insert_input
    , registered_at : OptionalArgument ScalarCodecs.Timestamptz
    , role : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    , tag : OptionalArgument Tag_arr_rel_insert_input
    , tasks_fixed_time : OptionalArgument Task_fixed_time_arr_rel_insert_input
    , tasks_rss : OptionalArgument Task_rss_arr_rel_insert_input
    }


{-| Type for the User\_insert\_input input object.
-}
type User_insert_input
    = User_insert_input User_insert_inputRaw


{-| Encode a User\_insert\_input into a value that can be used as an argument.
-}
encodeUser_insert_input : User_insert_input -> Value
encodeUser_insert_input (User_insert_input input____) =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input____.active ), ( "email", Encode.string |> Encode.optional input____.email ), ( "email_confirm_code", Encode.string |> Encode.optional input____.email_confirm_code ), ( "email_confirm_code_issued_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.email_confirm_code_issued_at ), ( "email_confirmed", Encode.bool |> Encode.optional input____.email_confirmed ), ( "email_confirmed_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.email_confirmed_at ), ( "id", Encode.string |> Encode.optional input____.id ), ( "last_seen", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_seen ), ( "medias", encodeMedia_arr_rel_insert_input |> Encode.optional input____.medias ), ( "messages", encodeMessage_arr_rel_insert_input |> Encode.optional input____.messages ), ( "registered_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.registered_at ), ( "role", Encode.enum Hasura.Enum.Role_enum.toString |> Encode.optional input____.role ), ( "tag", encodeTag_arr_rel_insert_input |> Encode.optional input____.tag ), ( "tasks_fixed_time", encodeTask_fixed_time_arr_rel_insert_input |> Encode.optional input____.tasks_fixed_time ), ( "tasks_rss", encodeTask_rss_arr_rel_insert_input |> Encode.optional input____.tasks_rss ) ]


buildUser_obj_rel_insert_input :
    User_obj_rel_insert_inputRequiredFields
    -> (User_obj_rel_insert_inputOptionalFields -> User_obj_rel_insert_inputOptionalFields)
    -> User_obj_rel_insert_input
buildUser_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    User_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias User_obj_rel_insert_inputRequiredFields =
    { data : User_insert_input }


type alias User_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_obj_rel_insert_input` attributes. Note that this type
needs to use the `User_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_obj_rel_insert_inputRaw =
    { data : User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_obj\_rel\_insert\_input input object.
-}
type User_obj_rel_insert_input
    = User_obj_rel_insert_input User_obj_rel_insert_inputRaw


{-| Encode a User\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_obj_rel_insert_input : User_obj_rel_insert_input -> Value
encodeUser_obj_rel_insert_input (User_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeUser_insert_input input____.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input____.on_conflict ) ]


buildUser_on_conflict :
    User_on_conflictRequiredFields
    -> (User_on_conflictOptionalFields -> User_on_conflictOptionalFields)
    -> User_on_conflict
buildUser_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    User_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias User_on_conflictRequiredFields =
    { constraint : Hasura.Enum.User_constraint.User_constraint
    , update_columns : List Hasura.Enum.User_update_column.User_update_column
    }


type alias User_on_conflictOptionalFields =
    { where_ : OptionalArgument User_bool_exp }


{-| Type alias for the `User_on_conflict` attributes. Note that this type
needs to use the `User_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_on_conflictRaw =
    { constraint : Hasura.Enum.User_constraint.User_constraint
    , update_columns : List Hasura.Enum.User_update_column.User_update_column
    , where_ : OptionalArgument User_bool_exp
    }


{-| Type for the User\_on\_conflict input object.
-}
type User_on_conflict
    = User_on_conflict User_on_conflictRaw


{-| Encode a User\_on\_conflict into a value that can be used as an argument.
-}
encodeUser_on_conflict : User_on_conflict -> Value
encodeUser_on_conflict (User_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.User_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.User_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeUser_bool_exp |> Encode.optional input____.where_ ) ]


buildUser_order_by :
    (User_order_byOptionalFields -> User_order_byOptionalFields)
    -> User_order_by
buildUser_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { active = Absent, email = Absent, email_confirm_code = Absent, email_confirm_code_issued_at = Absent, email_confirmed = Absent, email_confirmed_at = Absent, id = Absent, last_seen = Absent, medias_aggregate = Absent, messages_aggregate = Absent, registered_at = Absent, role = Absent, tag_aggregate = Absent, tasks_fixed_time_aggregate = Absent, tasks_rss_aggregate = Absent }
    in
    { active = optionals____.active, email = optionals____.email, email_confirm_code = optionals____.email_confirm_code, email_confirm_code_issued_at = optionals____.email_confirm_code_issued_at, email_confirmed = optionals____.email_confirmed, email_confirmed_at = optionals____.email_confirmed_at, id = optionals____.id, last_seen = optionals____.last_seen, medias_aggregate = optionals____.medias_aggregate, messages_aggregate = optionals____.messages_aggregate, registered_at = optionals____.registered_at, role = optionals____.role, tag_aggregate = optionals____.tag_aggregate, tasks_fixed_time_aggregate = optionals____.tasks_fixed_time_aggregate, tasks_rss_aggregate = optionals____.tasks_rss_aggregate }


type alias User_order_byOptionalFields =
    { active : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirm_code : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirm_code_issued_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirmed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirmed_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , medias_aggregate : OptionalArgument Media_aggregate_order_by
    , messages_aggregate : OptionalArgument Message_aggregate_order_by
    , registered_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , role : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_aggregate : OptionalArgument Tag_aggregate_order_by
    , tasks_fixed_time_aggregate : OptionalArgument Task_fixed_time_aggregate_order_by
    , tasks_rss_aggregate : OptionalArgument Task_rss_aggregate_order_by
    }


{-| Type for the User\_order\_by input object.
-}
type alias User_order_by =
    { active : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirm_code : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirm_code_issued_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirmed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , email_confirmed_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , medias_aggregate : OptionalArgument Media_aggregate_order_by
    , messages_aggregate : OptionalArgument Message_aggregate_order_by
    , registered_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , role : OptionalArgument Hasura.Enum.Order_by.Order_by
    , tag_aggregate : OptionalArgument Tag_aggregate_order_by
    , tasks_fixed_time_aggregate : OptionalArgument Task_fixed_time_aggregate_order_by
    , tasks_rss_aggregate : OptionalArgument Task_rss_aggregate_order_by
    }


{-| Encode a User\_order\_by into a value that can be used as an argument.
-}
encodeUser_order_by : User_order_by -> Value
encodeUser_order_by input____ =
    Encode.maybeObject
        [ ( "active", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.active ), ( "email", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.email ), ( "email_confirm_code", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.email_confirm_code ), ( "email_confirm_code_issued_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.email_confirm_code_issued_at ), ( "email_confirmed", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.email_confirmed ), ( "email_confirmed_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.email_confirmed_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.last_seen ), ( "medias_aggregate", encodeMedia_aggregate_order_by |> Encode.optional input____.medias_aggregate ), ( "messages_aggregate", encodeMessage_aggregate_order_by |> Encode.optional input____.messages_aggregate ), ( "registered_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.registered_at ), ( "role", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input____.role ), ( "tag_aggregate", encodeTag_aggregate_order_by |> Encode.optional input____.tag_aggregate ), ( "tasks_fixed_time_aggregate", encodeTask_fixed_time_aggregate_order_by |> Encode.optional input____.tasks_fixed_time_aggregate ), ( "tasks_rss_aggregate", encodeTask_rss_aggregate_order_by |> Encode.optional input____.tasks_rss_aggregate ) ]


buildUser_pk_columns_input :
    User_pk_columns_inputRequiredFields
    -> User_pk_columns_input
buildUser_pk_columns_input required____ =
    { id = required____.id }


type alias User_pk_columns_inputRequiredFields =
    { id : String }


{-| Type for the User\_pk\_columns\_input input object.
-}
type alias User_pk_columns_input =
    { id : String }


{-| Encode a User\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeUser_pk_columns_input : User_pk_columns_input -> Value
encodeUser_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "id", Encode.string input____.id |> Just ) ]


buildUser_set_input :
    (User_set_inputOptionalFields -> User_set_inputOptionalFields)
    -> User_set_input
buildUser_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { active = Absent, email = Absent, email_confirm_code = Absent, email_confirm_code_issued_at = Absent, email_confirmed = Absent, email_confirmed_at = Absent, id = Absent, last_seen = Absent, registered_at = Absent, role = Absent }
    in
    { active = optionals____.active, email = optionals____.email, email_confirm_code = optionals____.email_confirm_code, email_confirm_code_issued_at = optionals____.email_confirm_code_issued_at, email_confirmed = optionals____.email_confirmed, email_confirmed_at = optionals____.email_confirmed_at, id = optionals____.id, last_seen = optionals____.last_seen, registered_at = optionals____.registered_at, role = optionals____.role }


type alias User_set_inputOptionalFields =
    { active : OptionalArgument Bool
    , email : OptionalArgument String
    , email_confirm_code : OptionalArgument String
    , email_confirm_code_issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , email_confirmed : OptionalArgument Bool
    , email_confirmed_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument String
    , last_seen : OptionalArgument ScalarCodecs.Timestamptz
    , registered_at : OptionalArgument ScalarCodecs.Timestamptz
    , role : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    }


{-| Type for the User\_set\_input input object.
-}
type alias User_set_input =
    { active : OptionalArgument Bool
    , email : OptionalArgument String
    , email_confirm_code : OptionalArgument String
    , email_confirm_code_issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , email_confirmed : OptionalArgument Bool
    , email_confirmed_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument String
    , last_seen : OptionalArgument ScalarCodecs.Timestamptz
    , registered_at : OptionalArgument ScalarCodecs.Timestamptz
    , role : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    }


{-| Encode a User\_set\_input into a value that can be used as an argument.
-}
encodeUser_set_input : User_set_input -> Value
encodeUser_set_input input____ =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input____.active ), ( "email", Encode.string |> Encode.optional input____.email ), ( "email_confirm_code", Encode.string |> Encode.optional input____.email_confirm_code ), ( "email_confirm_code_issued_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.email_confirm_code_issued_at ), ( "email_confirmed", Encode.bool |> Encode.optional input____.email_confirmed ), ( "email_confirmed_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.email_confirmed_at ), ( "id", Encode.string |> Encode.optional input____.id ), ( "last_seen", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_seen ), ( "registered_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.registered_at ), ( "role", Encode.enum Hasura.Enum.Role_enum.toString |> Encode.optional input____.role ) ]


buildUser_stream_cursor_input :
    User_stream_cursor_inputRequiredFields
    -> (User_stream_cursor_inputOptionalFields -> User_stream_cursor_inputOptionalFields)
    -> User_stream_cursor_input
buildUser_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias User_stream_cursor_inputRequiredFields =
    { initial_value : User_stream_cursor_value_input }


type alias User_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the User\_stream\_cursor\_input input object.
-}
type alias User_stream_cursor_input =
    { initial_value : User_stream_cursor_value_input
    , ordering : OptionalArgument Hasura.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a User\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeUser_stream_cursor_input : User_stream_cursor_input -> Value
encodeUser_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeUser_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Hasura.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildUser_stream_cursor_value_input :
    (User_stream_cursor_value_inputOptionalFields -> User_stream_cursor_value_inputOptionalFields)
    -> User_stream_cursor_value_input
buildUser_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { active = Absent, email = Absent, email_confirm_code = Absent, email_confirm_code_issued_at = Absent, email_confirmed = Absent, email_confirmed_at = Absent, id = Absent, last_seen = Absent, registered_at = Absent, role = Absent }
    in
    { active = optionals____.active, email = optionals____.email, email_confirm_code = optionals____.email_confirm_code, email_confirm_code_issued_at = optionals____.email_confirm_code_issued_at, email_confirmed = optionals____.email_confirmed, email_confirmed_at = optionals____.email_confirmed_at, id = optionals____.id, last_seen = optionals____.last_seen, registered_at = optionals____.registered_at, role = optionals____.role }


type alias User_stream_cursor_value_inputOptionalFields =
    { active : OptionalArgument Bool
    , email : OptionalArgument String
    , email_confirm_code : OptionalArgument String
    , email_confirm_code_issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , email_confirmed : OptionalArgument Bool
    , email_confirmed_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument String
    , last_seen : OptionalArgument ScalarCodecs.Timestamptz
    , registered_at : OptionalArgument ScalarCodecs.Timestamptz
    , role : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    }


{-| Type for the User\_stream\_cursor\_value\_input input object.
-}
type alias User_stream_cursor_value_input =
    { active : OptionalArgument Bool
    , email : OptionalArgument String
    , email_confirm_code : OptionalArgument String
    , email_confirm_code_issued_at : OptionalArgument ScalarCodecs.Timestamptz
    , email_confirmed : OptionalArgument Bool
    , email_confirmed_at : OptionalArgument ScalarCodecs.Timestamptz
    , id : OptionalArgument String
    , last_seen : OptionalArgument ScalarCodecs.Timestamptz
    , registered_at : OptionalArgument ScalarCodecs.Timestamptz
    , role : OptionalArgument Hasura.Enum.Role_enum.Role_enum
    }


{-| Encode a User\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeUser_stream_cursor_value_input : User_stream_cursor_value_input -> Value
encodeUser_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "active", Encode.bool |> Encode.optional input____.active ), ( "email", Encode.string |> Encode.optional input____.email ), ( "email_confirm_code", Encode.string |> Encode.optional input____.email_confirm_code ), ( "email_confirm_code_issued_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.email_confirm_code_issued_at ), ( "email_confirmed", Encode.bool |> Encode.optional input____.email_confirmed ), ( "email_confirmed_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.email_confirmed_at ), ( "id", Encode.string |> Encode.optional input____.id ), ( "last_seen", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.last_seen ), ( "registered_at", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input____.registered_at ), ( "role", Encode.enum Hasura.Enum.Role_enum.toString |> Encode.optional input____.role ) ]


buildUser_updates :
    User_updatesRequiredFields
    -> (User_updatesOptionalFields -> User_updatesOptionalFields)
    -> User_updates
buildUser_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    User_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias User_updatesRequiredFields =
    { where_ : User_bool_exp }


type alias User_updatesOptionalFields =
    { set_ : OptionalArgument User_set_input }


{-| Type alias for the `User_updates` attributes. Note that this type
needs to use the `User_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_updatesRaw =
    { set_ : OptionalArgument User_set_input
    , where_ : User_bool_exp
    }


{-| Type for the User\_updates input object.
-}
type User_updates
    = User_updates User_updatesRaw


{-| Encode a User\_updates into a value that can be used as an argument.
-}
encodeUser_updates : User_updates -> Value
encodeUser_updates (User_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeUser_set_input |> Encode.optional input____.set_ ), ( "where", encodeUser_bool_exp input____.where_ |> Just ) ]


buildUuid_comparison_exp :
    (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields)
    -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument ScalarCodecs.Uuid
    , gt_ : OptionalArgument ScalarCodecs.Uuid
    , gte_ : OptionalArgument ScalarCodecs.Uuid
    , in_ : OptionalArgument (List ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Uuid
    , lte_ : OptionalArgument ScalarCodecs.Uuid
    , neq_ : OptionalArgument ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List ScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument ScalarCodecs.Uuid
    , gt_ : OptionalArgument ScalarCodecs.Uuid
    , gte_ : OptionalArgument ScalarCodecs.Uuid
    , in_ : OptionalArgument (List ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Uuid
    , lte_ : OptionalArgument ScalarCodecs.Uuid
    , neq_ : OptionalArgument ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List ScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.eq_ ), ( "_gt", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.gt_ ), ( "_gte", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.gte_ ), ( "_in", ((ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.lt_ ), ( "_lte", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.lte_ ), ( "_neq", (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input____.neq_ ), ( "_nin", ((ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input____.nin_ ) ]
