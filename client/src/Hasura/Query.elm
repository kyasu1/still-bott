-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.Query exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Media_select_column
import Hasura.Enum.Message_select_column
import Hasura.Enum.Role_select_column
import Hasura.Enum.Session_select_column
import Hasura.Enum.Tag_select_column
import Hasura.Enum.Task_fixed_time_select_column
import Hasura.Enum.Task_rss_select_column
import Hasura.Enum.User_select_column
import Hasura.InputObject
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.Union
import Json.Decode as Decode exposing (Decoder)
import ScalarCodecs


type alias GetTokenRequiredArguments =
    { user_id : String }


getToken :
    GetTokenRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.GetTokenOutput
    -> SelectionSet (Maybe decodesTo) RootQuery
getToken requiredArgs____ object____ =
    Object.selectionForCompositeField "getToken" [ Argument.required "user_id" requiredArgs____.user_id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias GetUserRequiredArguments =
    { user_id : String }


getUser :
    GetUserRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.GetUserOutput
    -> SelectionSet (Maybe decodesTo) RootQuery
getUser requiredArgs____ object____ =
    Object.selectionForCompositeField "getUser" [ Argument.required "user_id" requiredArgs____.user_id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias MediaOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Media_select_column.Media_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Media_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Media_bool_exp
    }


{-| fetch data from the table: "media"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
media :
    (MediaOptionalArguments -> MediaOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (List decodesTo) RootQuery
media fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Media_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMedia_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMedia_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "media" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MediaAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Media_select_column.Media_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Media_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Media_bool_exp
    }


{-| fetch aggregated fields from the table: "media"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
media_aggregate :
    (MediaAggregateOptionalArguments -> MediaAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Media_aggregate
    -> SelectionSet decodesTo RootQuery
media_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Media_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMedia_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMedia_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "media_aggregate" optionalArgs____ object____ Basics.identity


type alias MediaByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "media" using primary key columns
-}
media_by_pk :
    MediaByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (Maybe decodesTo) RootQuery
media_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "media_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias MessageOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Message_select_column.Message_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Message_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Message_bool_exp
    }


{-| fetch data from the table: "message"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
message :
    (MessageOptionalArguments -> MessageOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (List decodesTo) RootQuery
message fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Message_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMessage_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMessage_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "message" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MessageAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Message_select_column.Message_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Message_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Message_bool_exp
    }


{-| fetch aggregated fields from the table: "message"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
message_aggregate :
    (MessageAggregateOptionalArguments -> MessageAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Message_aggregate
    -> SelectionSet decodesTo RootQuery
message_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Message_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeMessage_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeMessage_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "message_aggregate" optionalArgs____ object____ Basics.identity


type alias MessageByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "message" using primary key columns
-}
message_by_pk :
    MessageByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (Maybe decodesTo) RootQuery
message_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "message_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias RoleOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Role_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Role_bool_exp
    }


{-| fetch data from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role :
    (RoleOptionalArguments -> RoleOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (List decodesTo) RootQuery
role fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias RoleAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Role_select_column.Role_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Role_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Role_bool_exp
    }


{-| fetch aggregated fields from the table: "role"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
role_aggregate :
    (RoleAggregateOptionalArguments -> RoleAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Role_aggregate
    -> SelectionSet decodesTo RootQuery
role_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Role_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeRole_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeRole_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "role_aggregate" optionalArgs____ object____ Basics.identity


type alias RoleByPkRequiredArguments =
    { value : String }


{-| fetch data from the table: "role" using primary key columns
-}
role_by_pk :
    RoleByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (Maybe decodesTo) RootQuery
role_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "role_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias SessionOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Session_select_column.Session_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Session_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Session_bool_exp
    }


{-| fetch data from the table: "session"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
session :
    (SessionOptionalArguments -> SessionOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (List decodesTo) RootQuery
session fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Session_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeSession_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeSession_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "session" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias SessionAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Session_select_column.Session_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Session_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Session_bool_exp
    }


{-| fetch aggregated fields from the table: "session"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
session_aggregate :
    (SessionAggregateOptionalArguments -> SessionAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Session_aggregate
    -> SelectionSet decodesTo RootQuery
session_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Session_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeSession_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeSession_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "session_aggregate" optionalArgs____ object____ Basics.identity


type alias SessionByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "session" using primary key columns
-}
session_by_pk :
    SessionByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (Maybe decodesTo) RootQuery
session_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "session_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias TagOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Tag_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Tag_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag :
    (TagOptionalArguments -> TagOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (List decodesTo) RootQuery
tag fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTag_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tag" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TagAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Tag_select_column.Tag_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Tag_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Tag_bool_exp
    }


{-| An aggregate relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
tag_aggregate :
    (TagAggregateOptionalArguments -> TagAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Tag_aggregate
    -> SelectionSet decodesTo RootQuery
tag_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Tag_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTag_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTag_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "tag_aggregate" optionalArgs____ object____ Basics.identity


type alias TagByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "tag" using primary key columns
-}
tag_by_pk :
    TagByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (Maybe decodesTo) RootQuery
tag_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "tag_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias TaskFixedTimeOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_fixed_time_select_column.Task_fixed_time_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_fixed_time_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_fixed_time_bool_exp
    }


{-| fetch data from the table: "task\_fixed\_time"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_fixed_time :
    (TaskFixedTimeOptionalArguments -> TaskFixedTimeOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (List decodesTo) RootQuery
task_fixed_time fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_fixed_time_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_fixed_time_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_fixed_time" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TaskFixedTimeAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_fixed_time_select_column.Task_fixed_time_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_fixed_time_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_fixed_time_bool_exp
    }


{-| fetch aggregated fields from the table: "task\_fixed\_time"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_fixed_time_aggregate :
    (TaskFixedTimeAggregateOptionalArguments -> TaskFixedTimeAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time_aggregate
    -> SelectionSet decodesTo RootQuery
task_fixed_time_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_fixed_time_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_fixed_time_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_fixed_time_aggregate" optionalArgs____ object____ Basics.identity


type alias TaskFixedTimeByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "task\_fixed\_time" using primary key columns
-}
task_fixed_time_by_pk :
    TaskFixedTimeByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (Maybe decodesTo) RootQuery
task_fixed_time_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "task_fixed_time_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias TaskRssOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_rss_select_column.Task_rss_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_rss_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_rss_bool_exp
    }


{-| fetch data from the table: "task\_rss"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_rss :
    (TaskRssOptionalArguments -> TaskRssOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (List decodesTo) RootQuery
task_rss fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_rss_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_rss_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_rss" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TaskRssAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.Task_rss_select_column.Task_rss_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.Task_rss_order_by)
    , where_ : OptionalArgument Hasura.InputObject.Task_rss_bool_exp
    }


{-| fetch aggregated fields from the table: "task\_rss"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
task_rss_aggregate :
    (TaskRssAggregateOptionalArguments -> TaskRssAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.Task_rss_aggregate
    -> SelectionSet decodesTo RootQuery
task_rss_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.Task_rss_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeTask_rss_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "task_rss_aggregate" optionalArgs____ object____ Basics.identity


type alias TaskRssByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| fetch data from the table: "task\_rss" using primary key columns
-}
task_rss_by_pk :
    TaskRssByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (Maybe decodesTo) RootQuery
task_rss_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "task_rss_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias UserOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.User_select_column.User_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.User_order_by)
    , where_ : OptionalArgument Hasura.InputObject.User_bool_exp
    }


{-| fetch data from the table: "user"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
user :
    (UserOptionalArguments -> UserOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (List decodesTo) RootQuery
user fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.User_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeUser_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeUser_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "user" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias UserAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List Hasura.Enum.User_select_column.User_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List Hasura.InputObject.User_order_by)
    , where_ : OptionalArgument Hasura.InputObject.User_bool_exp
    }


{-| fetch aggregated fields from the table: "user"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
user_aggregate :
    (UserAggregateOptionalArguments -> UserAggregateOptionalArguments)
    -> SelectionSet decodesTo Hasura.Object.User_aggregate
    -> SelectionSet decodesTo RootQuery
user_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum Hasura.Enum.User_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (Hasura.InputObject.encodeUser_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ Hasura.InputObject.encodeUser_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "user_aggregate" optionalArgs____ object____ Basics.identity


type alias UserByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "user" using primary key columns
-}
user_by_pk :
    UserByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
user_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "user_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)
