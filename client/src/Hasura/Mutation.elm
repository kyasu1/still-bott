-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.Mutation exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.InputObject
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.Union
import Json.Decode as Decode exposing (Decoder)
import ScalarCodecs


type alias ConfirmEmailRequiredArguments =
    { args : Hasura.InputObject.ConfirmEmailInput }


confirmEmail :
    ConfirmEmailRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.ConfirmEmailOutput
    -> SelectionSet decodesTo RootMutation
confirmEmail requiredArgs____ object____ =
    Object.selectionForCompositeField "confirmEmail" [ Argument.required "args" requiredArgs____.args Hasura.InputObject.encodeConfirmEmailInput ] object____ Basics.identity


type alias DeleteImageRequiredArguments =
    { args : Hasura.InputObject.DeleteImageInput }


deleteImage :
    DeleteImageRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.DeleteImageOutput
    -> SelectionSet decodesTo RootMutation
deleteImage requiredArgs____ object____ =
    Object.selectionForCompositeField "deleteImage" [ Argument.required "args" requiredArgs____.args Hasura.InputObject.encodeDeleteImageInput ] object____ Basics.identity


type alias DeleteMediaRequiredArguments =
    { where_ : Hasura.InputObject.Media_bool_exp }


{-| delete data from the table: "media"

  - where\_ - filter the rows which have to be deleted

-}
delete_media :
    DeleteMediaRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_media requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_media" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeMedia_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteMediaByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| delete single row from the table: "media"
-}
delete_media_by_pk :
    DeleteMediaByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_media_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_media_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteMessageRequiredArguments =
    { where_ : Hasura.InputObject.Message_bool_exp }


{-| delete data from the table: "message"

  - where\_ - filter the rows which have to be deleted

-}
delete_message :
    DeleteMessageRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_message requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_message" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeMessage_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteMessageByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| delete single row from the table: "message"
-}
delete_message_by_pk :
    DeleteMessageByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_message_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_message_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRoleRequiredArguments =
    { where_ : Hasura.InputObject.Role_bool_exp }


{-| delete data from the table: "role"

  - where\_ - filter the rows which have to be deleted

-}
delete_role :
    DeleteRoleRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_role requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_role" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeRole_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteRoleByPkRequiredArguments =
    { value : String }


{-| delete single row from the table: "role"
-}
delete_role_by_pk :
    DeleteRoleByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_role_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_role_by_pk" [ Argument.required "value" requiredArgs____.value Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteSessionRequiredArguments =
    { where_ : Hasura.InputObject.Session_bool_exp }


{-| delete data from the table: "session"

  - where\_ - filter the rows which have to be deleted

-}
delete_session :
    DeleteSessionRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_session requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_session" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeSession_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteSessionByPkRequiredArguments =
    { id : String }


{-| delete single row from the table: "session"
-}
delete_session_by_pk :
    DeleteSessionByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_session_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_session_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTagRequiredArguments =
    { where_ : Hasura.InputObject.Tag_bool_exp }


{-| delete data from the table: "tag"

  - where\_ - filter the rows which have to be deleted

-}
delete_tag :
    DeleteTagRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_tag requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_tag" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeTag_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTagByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| delete single row from the table: "tag"
-}
delete_tag_by_pk :
    DeleteTagByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_tag_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_tag_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTaskFixedTimeRequiredArguments =
    { where_ : Hasura.InputObject.Task_fixed_time_bool_exp }


{-| delete data from the table: "task\_fixed\_time"

  - where\_ - filter the rows which have to be deleted

-}
delete_task_fixed_time :
    DeleteTaskFixedTimeRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_task_fixed_time requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_task_fixed_time" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTaskFixedTimeByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| delete single row from the table: "task\_fixed\_time"
-}
delete_task_fixed_time_by_pk :
    DeleteTaskFixedTimeByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_task_fixed_time_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_task_fixed_time_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTaskRssRequiredArguments =
    { where_ : Hasura.InputObject.Task_rss_bool_exp }


{-| delete data from the table: "task\_rss"

  - where\_ - filter the rows which have to be deleted

-}
delete_task_rss :
    DeleteTaskRssRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_task_rss requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_task_rss" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTaskRssByPkRequiredArguments =
    { id : ScalarCodecs.Uuid }


{-| delete single row from the table: "task\_rss"
-}
delete_task_rss_by_pk :
    DeleteTaskRssByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_task_rss_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_task_rss_by_pk" [ Argument.required "id" requiredArgs____.id (ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteUserRequiredArguments =
    { where_ : Hasura.InputObject.User_bool_exp }


{-| delete data from the table: "user"

  - where\_ - filter the rows which have to be deleted

-}
delete_user :
    DeleteUserRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_user requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_user" [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeUser_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteUserByPkRequiredArguments =
    { id : String }


{-| delete single row from the table: "user"
-}
delete_user_by_pk :
    DeleteUserByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_user_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_user_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias InsertMediaOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Media_on_conflict }


type alias InsertMediaRequiredArguments =
    { objects : List Hasura.InputObject.Media_insert_input }


{-| insert data into the table: "media"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_media :
    (InsertMediaOptionalArguments -> InsertMediaOptionalArguments)
    -> InsertMediaRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_media fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeMedia_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_media" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeMedia_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertMediaOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Media_on_conflict }


type alias InsertMediaOneRequiredArguments =
    { object : Hasura.InputObject.Media_insert_input }


{-| insert a single row into the table: "media"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_media_one :
    (InsertMediaOneOptionalArguments -> InsertMediaOneOptionalArguments)
    -> InsertMediaOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_media_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeMedia_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_media_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeMedia_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertMessageOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Message_on_conflict }


type alias InsertMessageRequiredArguments =
    { objects : List Hasura.InputObject.Message_insert_input }


{-| insert data into the table: "message"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_message :
    (InsertMessageOptionalArguments -> InsertMessageOptionalArguments)
    -> InsertMessageRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_message fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeMessage_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_message" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeMessage_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertMessageOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Message_on_conflict }


type alias InsertMessageOneRequiredArguments =
    { object : Hasura.InputObject.Message_insert_input }


{-| insert a single row into the table: "message"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_message_one :
    (InsertMessageOneOptionalArguments -> InsertMessageOneOptionalArguments)
    -> InsertMessageOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_message_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeMessage_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_message_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeMessage_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRoleOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Role_on_conflict }


type alias InsertRoleRequiredArguments =
    { objects : List Hasura.InputObject.Role_insert_input }


{-| insert data into the table: "role"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_role :
    (InsertRoleOptionalArguments -> InsertRoleOptionalArguments)
    -> InsertRoleRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_role fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeRole_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_role" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeRole_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertRoleOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Role_on_conflict }


type alias InsertRoleOneRequiredArguments =
    { object : Hasura.InputObject.Role_insert_input }


{-| insert a single row into the table: "role"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_role_one :
    (InsertRoleOneOptionalArguments -> InsertRoleOneOptionalArguments)
    -> InsertRoleOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_role_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeRole_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_role_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeRole_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertSessionOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Session_on_conflict }


type alias InsertSessionRequiredArguments =
    { objects : List Hasura.InputObject.Session_insert_input }


{-| insert data into the table: "session"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_session :
    (InsertSessionOptionalArguments -> InsertSessionOptionalArguments)
    -> InsertSessionRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_session fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeSession_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_session" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeSession_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertSessionOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Session_on_conflict }


type alias InsertSessionOneRequiredArguments =
    { object : Hasura.InputObject.Session_insert_input }


{-| insert a single row into the table: "session"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_session_one :
    (InsertSessionOneOptionalArguments -> InsertSessionOneOptionalArguments)
    -> InsertSessionOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_session_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeSession_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_session_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeSession_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTagOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Tag_on_conflict }


type alias InsertTagRequiredArguments =
    { objects : List Hasura.InputObject.Tag_insert_input }


{-| insert data into the table: "tag"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_tag :
    (InsertTagOptionalArguments -> InsertTagOptionalArguments)
    -> InsertTagRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_tag fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeTag_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_tag" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeTag_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTagOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Tag_on_conflict }


type alias InsertTagOneRequiredArguments =
    { object : Hasura.InputObject.Tag_insert_input }


{-| insert a single row into the table: "tag"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_tag_one :
    (InsertTagOneOptionalArguments -> InsertTagOneOptionalArguments)
    -> InsertTagOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_tag_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeTag_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_tag_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeTag_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTaskFixedTimeOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Task_fixed_time_on_conflict }


type alias InsertTaskFixedTimeRequiredArguments =
    { objects : List Hasura.InputObject.Task_fixed_time_insert_input }


{-| insert data into the table: "task\_fixed\_time"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_task_fixed_time :
    (InsertTaskFixedTimeOptionalArguments -> InsertTaskFixedTimeOptionalArguments)
    -> InsertTaskFixedTimeRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_task_fixed_time fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeTask_fixed_time_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_task_fixed_time" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeTask_fixed_time_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTaskFixedTimeOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Task_fixed_time_on_conflict }


type alias InsertTaskFixedTimeOneRequiredArguments =
    { object : Hasura.InputObject.Task_fixed_time_insert_input }


{-| insert a single row into the table: "task\_fixed\_time"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_task_fixed_time_one :
    (InsertTaskFixedTimeOneOptionalArguments -> InsertTaskFixedTimeOneOptionalArguments)
    -> InsertTaskFixedTimeOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_task_fixed_time_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeTask_fixed_time_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_task_fixed_time_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeTask_fixed_time_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTaskRssOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Task_rss_on_conflict }


type alias InsertTaskRssRequiredArguments =
    { objects : List Hasura.InputObject.Task_rss_insert_input }


{-| insert data into the table: "task\_rss"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_task_rss :
    (InsertTaskRssOptionalArguments -> InsertTaskRssOptionalArguments)
    -> InsertTaskRssRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_task_rss fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeTask_rss_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_task_rss" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeTask_rss_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTaskRssOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.Task_rss_on_conflict }


type alias InsertTaskRssOneRequiredArguments =
    { object : Hasura.InputObject.Task_rss_insert_input }


{-| insert a single row into the table: "task\_rss"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_task_rss_one :
    (InsertTaskRssOneOptionalArguments -> InsertTaskRssOneOptionalArguments)
    -> InsertTaskRssOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_task_rss_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeTask_rss_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_task_rss_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeTask_rss_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertUserOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.User_on_conflict }


type alias InsertUserRequiredArguments =
    { objects : List Hasura.InputObject.User_insert_input }


{-| insert data into the table: "user"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_user :
    (InsertUserOptionalArguments -> InsertUserOptionalArguments)
    -> InsertUserRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_user fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeUser_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_user" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Hasura.InputObject.encodeUser_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertUserOneOptionalArguments =
    { on_conflict : OptionalArgument Hasura.InputObject.User_on_conflict }


type alias InsertUserOneRequiredArguments =
    { object : Hasura.InputObject.User_insert_input }


{-| insert a single row into the table: "user"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_user_one :
    (InsertUserOneOptionalArguments -> InsertUserOneOptionalArguments)
    -> InsertUserOneRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_user_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Hasura.InputObject.encodeUser_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_user_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Hasura.InputObject.encodeUser_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias MinioGetUploadUrlRequiredArguments =
    { args : Hasura.InputObject.MinioGetUploadUrlInput }


minioGetUploadUrl :
    MinioGetUploadUrlRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.MinioGetUploadUrlOutput
    -> SelectionSet decodesTo RootMutation
minioGetUploadUrl requiredArgs____ object____ =
    Object.selectionForCompositeField "minioGetUploadUrl" [ Argument.required "args" requiredArgs____.args Hasura.InputObject.encodeMinioGetUploadUrlInput ] object____ Basics.identity


type alias RegisterEmailRequiredArguments =
    { args : Hasura.InputObject.RegisterEmailInput }


{-| registerEmail
-}
registerEmail :
    RegisterEmailRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.RegisterEmailOutput
    -> SelectionSet decodesTo RootMutation
registerEmail requiredArgs____ object____ =
    Object.selectionForCompositeField "registerEmail" [ Argument.required "args" requiredArgs____.args Hasura.InputObject.encodeRegisterEmailInput ] object____ Basics.identity


type alias RestartSchedulerRequiredArguments =
    { args : Hasura.InputObject.BooleanInput }


restartScheduler :
    RestartSchedulerRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.BooleanOutput
    -> SelectionSet decodesTo RootMutation
restartScheduler requiredArgs____ object____ =
    Object.selectionForCompositeField "restartScheduler" [ Argument.required "args" requiredArgs____.args Hasura.InputObject.encodeBooleanInput ] object____ Basics.identity


type alias SaveMediaRequiredArguments =
    { args : Hasura.InputObject.SaveMediaInput }


saveMedia :
    SaveMediaRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.SaveMediaOutput
    -> SelectionSet decodesTo RootMutation
saveMedia requiredArgs____ object____ =
    Object.selectionForCompositeField "saveMedia" [ Argument.required "args" requiredArgs____.args Hasura.InputObject.encodeSaveMediaInput ] object____ Basics.identity


type alias UpdateMediaOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Media_set_input }


type alias UpdateMediaRequiredArguments =
    { where_ : Hasura.InputObject.Media_bool_exp }


{-| update data of the table: "media"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_media :
    (UpdateMediaOptionalArguments -> UpdateMediaOptionalArguments)
    -> UpdateMediaRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_media fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeMedia_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_media" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeMedia_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMediaByPkOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Media_set_input }


type alias UpdateMediaByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Media_pk_columns_input }


{-| update single row of the table: "media"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_media_by_pk :
    (UpdateMediaByPkOptionalArguments -> UpdateMediaByPkOptionalArguments)
    -> UpdateMediaByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media
    -> SelectionSet (Maybe decodesTo) RootMutation
update_media_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeMedia_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_media_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeMedia_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMediaManyRequiredArguments =
    { updates : List Hasura.InputObject.Media_updates }


{-| update multiples rows of table: "media"

  - updates - updates to execute, in order

-}
update_media_many :
    UpdateMediaManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Media_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_media_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_media_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeMedia_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateMessageOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Message_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Message_set_input
    }


type alias UpdateMessageRequiredArguments =
    { where_ : Hasura.InputObject.Message_bool_exp }


{-| update data of the table: "message"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_message :
    (UpdateMessageOptionalArguments -> UpdateMessageOptionalArguments)
    -> UpdateMessageRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_message fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Hasura.InputObject.encodeMessage_inc_input, Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeMessage_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_message" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeMessage_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMessageByPkOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Message_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Message_set_input
    }


type alias UpdateMessageByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Message_pk_columns_input }


{-| update single row of the table: "message"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_message_by_pk :
    (UpdateMessageByPkOptionalArguments -> UpdateMessageByPkOptionalArguments)
    -> UpdateMessageByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message
    -> SelectionSet (Maybe decodesTo) RootMutation
update_message_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Hasura.InputObject.encodeMessage_inc_input, Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeMessage_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_message_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeMessage_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMessageManyRequiredArguments =
    { updates : List Hasura.InputObject.Message_updates }


{-| update multiples rows of table: "message"

  - updates - updates to execute, in order

-}
update_message_many :
    UpdateMessageManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Message_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_message_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_message_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeMessage_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateRoleOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Role_set_input }


type alias UpdateRoleRequiredArguments =
    { where_ : Hasura.InputObject.Role_bool_exp }


{-| update data of the table: "role"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_role :
    (UpdateRoleOptionalArguments -> UpdateRoleOptionalArguments)
    -> UpdateRoleRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_role fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeRole_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_role" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeRole_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRoleByPkOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Role_set_input }


type alias UpdateRoleByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Role_pk_columns_input }


{-| update single row of the table: "role"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_role_by_pk :
    (UpdateRoleByPkOptionalArguments -> UpdateRoleByPkOptionalArguments)
    -> UpdateRoleByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role
    -> SelectionSet (Maybe decodesTo) RootMutation
update_role_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeRole_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_role_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeRole_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateRoleManyRequiredArguments =
    { updates : List Hasura.InputObject.Role_updates }


{-| update multiples rows of table: "role"

  - updates - updates to execute, in order

-}
update_role_many :
    UpdateRoleManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Role_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_role_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_role_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeRole_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateSessionOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Session_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Session_set_input
    }


type alias UpdateSessionRequiredArguments =
    { where_ : Hasura.InputObject.Session_bool_exp }


{-| update data of the table: "session"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_session :
    (UpdateSessionOptionalArguments -> UpdateSessionOptionalArguments)
    -> UpdateSessionRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_session fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Hasura.InputObject.encodeSession_inc_input, Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeSession_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_session" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeSession_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateSessionByPkOptionalArguments =
    { inc_ : OptionalArgument Hasura.InputObject.Session_inc_input
    , set_ : OptionalArgument Hasura.InputObject.Session_set_input
    }


type alias UpdateSessionByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Session_pk_columns_input }


{-| update single row of the table: "session"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_session_by_pk :
    (UpdateSessionByPkOptionalArguments -> UpdateSessionByPkOptionalArguments)
    -> UpdateSessionByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session
    -> SelectionSet (Maybe decodesTo) RootMutation
update_session_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Hasura.InputObject.encodeSession_inc_input, Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeSession_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_session_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeSession_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateSessionManyRequiredArguments =
    { updates : List Hasura.InputObject.Session_updates }


{-| update multiples rows of table: "session"

  - updates - updates to execute, in order

-}
update_session_many :
    UpdateSessionManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Session_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_session_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_session_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeSession_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateTagOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Tag_set_input }


type alias UpdateTagRequiredArguments =
    { where_ : Hasura.InputObject.Tag_bool_exp }


{-| update data of the table: "tag"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_tag :
    (UpdateTagOptionalArguments -> UpdateTagOptionalArguments)
    -> UpdateTagRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_tag fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeTag_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_tag" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeTag_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTagByPkOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Tag_set_input }


type alias UpdateTagByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Tag_pk_columns_input }


{-| update single row of the table: "tag"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_tag_by_pk :
    (UpdateTagByPkOptionalArguments -> UpdateTagByPkOptionalArguments)
    -> UpdateTagByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag
    -> SelectionSet (Maybe decodesTo) RootMutation
update_tag_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeTag_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_tag_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeTag_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTagManyRequiredArguments =
    { updates : List Hasura.InputObject.Tag_updates }


{-| update multiples rows of table: "tag"

  - updates - updates to execute, in order

-}
update_tag_many :
    UpdateTagManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Tag_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_tag_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_tag_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeTag_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateTaskFixedTimeOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Task_fixed_time_set_input }


type alias UpdateTaskFixedTimeRequiredArguments =
    { where_ : Hasura.InputObject.Task_fixed_time_bool_exp }


{-| update data of the table: "task\_fixed\_time"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_task_fixed_time :
    (UpdateTaskFixedTimeOptionalArguments -> UpdateTaskFixedTimeOptionalArguments)
    -> UpdateTaskFixedTimeRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_task_fixed_time fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeTask_fixed_time_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_task_fixed_time" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeTask_fixed_time_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTaskFixedTimeByPkOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Task_fixed_time_set_input }


type alias UpdateTaskFixedTimeByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Task_fixed_time_pk_columns_input }


{-| update single row of the table: "task\_fixed\_time"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_task_fixed_time_by_pk :
    (UpdateTaskFixedTimeByPkOptionalArguments -> UpdateTaskFixedTimeByPkOptionalArguments)
    -> UpdateTaskFixedTimeByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time
    -> SelectionSet (Maybe decodesTo) RootMutation
update_task_fixed_time_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeTask_fixed_time_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_task_fixed_time_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeTask_fixed_time_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTaskFixedTimeManyRequiredArguments =
    { updates : List Hasura.InputObject.Task_fixed_time_updates }


{-| update multiples rows of table: "task\_fixed\_time"

  - updates - updates to execute, in order

-}
update_task_fixed_time_many :
    UpdateTaskFixedTimeManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_fixed_time_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_task_fixed_time_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_task_fixed_time_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeTask_fixed_time_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateTaskRssOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Task_rss_set_input }


type alias UpdateTaskRssRequiredArguments =
    { where_ : Hasura.InputObject.Task_rss_bool_exp }


{-| update data of the table: "task\_rss"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_task_rss :
    (UpdateTaskRssOptionalArguments -> UpdateTaskRssOptionalArguments)
    -> UpdateTaskRssRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_task_rss fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeTask_rss_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_task_rss" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeTask_rss_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTaskRssByPkOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.Task_rss_set_input }


type alias UpdateTaskRssByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.Task_rss_pk_columns_input }


{-| update single row of the table: "task\_rss"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_task_rss_by_pk :
    (UpdateTaskRssByPkOptionalArguments -> UpdateTaskRssByPkOptionalArguments)
    -> UpdateTaskRssByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss
    -> SelectionSet (Maybe decodesTo) RootMutation
update_task_rss_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeTask_rss_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_task_rss_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeTask_rss_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTaskRssManyRequiredArguments =
    { updates : List Hasura.InputObject.Task_rss_updates }


{-| update multiples rows of table: "task\_rss"

  - updates - updates to execute, in order

-}
update_task_rss_many :
    UpdateTaskRssManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.Task_rss_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_task_rss_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_task_rss_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeTask_rss_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateUserOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.User_set_input }


type alias UpdateUserRequiredArguments =
    { where_ : Hasura.InputObject.User_bool_exp }


{-| update data of the table: "user"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_user :
    (UpdateUserOptionalArguments -> UpdateUserOptionalArguments)
    -> UpdateUserRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_user fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeUser_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_user" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Hasura.InputObject.encodeUser_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateUserByPkOptionalArguments =
    { set_ : OptionalArgument Hasura.InputObject.User_set_input }


type alias UpdateUserByPkRequiredArguments =
    { pk_columns : Hasura.InputObject.User_pk_columns_input }


{-| update single row of the table: "user"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_user_by_pk :
    (UpdateUserByPkOptionalArguments -> UpdateUserByPkOptionalArguments)
    -> UpdateUserByPkRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User
    -> SelectionSet (Maybe decodesTo) RootMutation
update_user_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Hasura.InputObject.encodeUser_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_user_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Hasura.InputObject.encodeUser_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateUserManyRequiredArguments =
    { updates : List Hasura.InputObject.User_updates }


{-| update multiples rows of table: "user"

  - updates - updates to execute, in order

-}
update_user_many :
    UpdateUserManyRequiredArguments
    -> SelectionSet decodesTo Hasura.Object.User_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_user_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_user_many" [ Argument.required "updates" requiredArgs____.updates (Hasura.InputObject.encodeUser_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)
